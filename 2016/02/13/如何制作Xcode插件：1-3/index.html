<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>如何制作Xcode插件：1/3 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="如何制作Xcode插件：1/3译者注：在学习写xcode插件的过程中，找了一些资料，其中www.raywenderlich.com中的三篇文章写得很好，这是其中的第一篇《How To Create an Xcode Plugin:Part1/3 》。

更新备注：这篇教程只用Xcode6.3.2测试过——如果你使用的其他版本的Xcode，那么你的经历可能会与这篇教程中的有一定出入。
苹果公司针对扩">
<meta property="og:type" content="article">
<meta property="og:title" content="如何制作Xcode插件：1/3">
<meta property="og:url" content="http://yoursite.com/2016/02/13/如何制作Xcode插件：1-3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="如何制作Xcode插件：1/3译者注：在学习写xcode插件的过程中，找了一些资料，其中www.raywenderlich.com中的三篇文章写得很好，这是其中的第一篇《How To Create an Xcode Plugin:Part1/3 》。

更新备注：这篇教程只用Xcode6.3.2测试过——如果你使用的其他版本的Xcode，那么你的经历可能会与这篇教程中的有一定出入。
苹果公司针对扩">
<meta property="og:image" content="http://cdn4.raywenderlich.com/wp-content/uploads/2015/04/Xcode_Swizzle_DispalAlert.png">
<meta property="og:image" content="http://cdn4.raywenderlich.com/wp-content/uploads/2015/05/Plugin_Swizzled_Titlebar.png">
<meta property="og:image" content="http://cdn2.raywenderlich.com/wp-content/uploads/2015/04/Plugin_Swizzle_Documentation-700x288.png">
<meta property="og:image" content="http://cdn5.raywenderlich.com/wp-content/uploads/2015/05/Xcode6.3.2.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="如何制作Xcode插件：1/3">
<meta name="twitter:description" content="如何制作Xcode插件：1/3译者注：在学习写xcode插件的过程中，找了一些资料，其中www.raywenderlich.com中的三篇文章写得很好，这是其中的第一篇《How To Create an Xcode Plugin:Part1/3 》。

更新备注：这篇教程只用Xcode6.3.2测试过——如果你使用的其他版本的Xcode，那么你的经历可能会与这篇教程中的有一定出入。
苹果公司针对扩">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="q" value="site:http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-如何制作Xcode插件：1-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/13/如何制作Xcode插件：1-3/" class="article-date">
  <time datetime="2016-02-13T06:38:13.000Z" itemprop="datePublished">2016-02-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      如何制作Xcode插件：1/3
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="如何制作Xcode插件：1/3"><a href="http://http://www.raywenderlich.com/94020/creating-an-xcode-plugin-part-1" target="_blank" rel="external">如何制作Xcode插件：1/3</a></h1><p>译者注：在学习写xcode插件的过程中，找了一些资料，其中<a href="http://www.raywenderlich.com" target="_blank" rel="external">www.raywenderlich.com</a>中的三篇文章写得很好，这是其中的第一篇《<a href="http://http://www.raywenderlich.com/94020/creating-an-xcode-plugin-part-1" target="_blank" rel="external">How To Create an Xcode Plugin:Part1/3 </a>》。</p>
<hr>
<p><strong>更新备注：</strong>这篇教程只用Xcode6.3.2测试过——如果你使用的其他版本的Xcode，那么你的经历可能会与这篇教程中的有一定出入。</p>
<p>苹果公司针对扩展其产品的“一刀切”的规则就像让人强吞下一颗难以忍受的药丸。尽管目前苹果公司强制iOS或者OS X平台的开发者使用它的工作流程，但是仍然可以通过制作插件的方式使Xcode更为适用。</p>
<p>这不是关于如何制作Xcode插件的苹果公司官方文档，但是开发社区已经做了数量惊人的工作致力于帮助让开发者拥有更为有效的工具。</p>
<p>从<a href="https://github.com/ksuther/KSImageNamed-Xcode" target="_blank" rel="external">autocompletion for images</a>，到nuking你的<a href="https://github.com/kattrali/deriveddata-exterminator" target="_blank" rel="external">Derived Data</a>，再到<a href="https://github.com/XVimProject/XVim" target="_blank" rel="external">vim editor</a>，Xcode插件社区已经推动了原本被认为可以推动的边界。</p>
<p>在这史诗般的三篇教程中，你将制作一款Xcode插件来恶搞你的搭档，而主演恶搞者的人没有一人比他更爱恶作剧——Ray本人。虽然这些插件看似轻松搞笑，但是你仍然可以从中学习到许多通过Xcode跟踪，如何找到你想要修改的元素，以及如何swizzle进你自己的函数。</p>
<p>你将会查阅一些未公开的框架，会用到如下技术：<a href="https://www.mikeash.com/pyblog/friday-qa-2011-12-16-disassembling-the-assembly-part-1.html" target="_blank" rel="external">X86汇编知识</a>，<a href="http://www.raywenderlich.com/79600/navigating-a-new-codebase" target="_blank" rel="external">源码的导航技巧</a>和在探索私有API和用<a href="http://nshipster.com/method-swizzling/" target="_blank" rel="external">method swizzling</a>做代码注入的<a href="http://www.raywenderlich.com/?s=lldb" target="_blank" rel="external">LLDB技术</a> 。由于会涉及到的方方面面较多，所以这篇教程会进行的较快。那么，在开始之前确保你的iOS或OS X平台在最佳状态吧！</p>
<p>使用Swift进行插件开发会严重复杂化这个原本就已经很棘手的题目，况且Swift调试工具相较于Objectvie-C的仍然有所不足。所以现在，(在这篇教程中)开发插件最好的选择是Objective-C。</p>
<hr>
<h2 id="开始">开始</h2><p>为了庆祝“恶搞搭档日”，你的Xcode插件将“瑞克摇摆”为你的牺牲者。稍等，什么是“瑞克摇摆”？它是免费版本的<a href="https://en.wikipedia.org/wiki/Rickrolling" target="_blank" rel="external">“瑞克摇摆”</a>的版权和版税，就是将牺牲者替换到大家原本预期会出现的内容里。当你完成后，插件将Xcode变成下面的样子：</p>
<ol>
<li><p>将Ray的脸蛋植入到Xcode的通知中（例如：编译成功或失败）。<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/04/Xcode_Swizzle_DispalAlert.png" alt=""></p>
</li>
<li><p>将Ray流行一时的歌曲植入到标题栏内，<strong>永不放弃你</strong>。<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/05/Plugin_Swizzled_Titlebar.png" alt=""></p>
</li>
<li><p>将所有Xcode文档请求都重置到<a href="https://www.youtube.com/watch?v=ce-_0opZzh0" target="_blank" rel="external">“瑞克摇摆”的录像</a><br><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/04/Plugin_Swizzle_Documentation-700x288.png" alt=""></p>
</li>
</ol>
<p>在教程的第一部分，你们将集中精力一路跟踪到负责显示“编译完成”通知的类，并将其修改为Ray的一张大头照。</p>
<h2 id="安装Alcatraz插件">安装Alcatraz插件</h2><p>在做任何事之前，都应该先安装<a href="http://alcatraz.io/" target="_blank" rel="external">Alcatraz</a>。Alcatraz是Xcode插件的管家，它的作者是天才的开发者<a href="https://twitter.com/kattrali" target="_blank" rel="external">@kattrali</a>，<a href="https://twitter.com/_supermarin" target="_blank" rel="external">@_supermarin</a>和<a href="https://twitter.com/JurreTweet" target="_blank" rel="external">@jurreTweet</a>。</p>
<p>安装Alcatraz，在终端上执行如下命令：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL http<span class="variable">s:</span>//raw.github.<span class="keyword">com</span>/supermarin/Alcatraz/master/Scripts/install.<span class="keyword">sh</span> | <span class="keyword">sh</span></span><br></pre></td></tr></table></figure>
<p>脚本执行完成后，重启Xcode。会看到Alcatraz bundle的如下提示框；点击<strong>Load Bundle</strong>。你一定想要更强力的Xcode，对不对？<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/05/Xcode6.3.2.png" alt=""></p>
<pre><code>**注意**：如果你不小心点击了“Skip Bundle”，可以通过在终端里执行如下命令再次开启这个提示框：

<span class="comment"><figure class="highlight"><figcaption><span>delete com.apple.dt.Xcode DVTPlugInManagerNonApplePlugIns-Xcode-6.3.2 ```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;&#22312;Xcode&#30340;**Window**&#33756;&#21333;&#20250;&#20986;&#29616;&#19968;&#20010;&#21517;&#20026;**Package Manager**&#30340;&#26032;&#36873;&#39033;&#12290;&#21046;&#20316;Xcode&#25554;&#20214;&#35201;&#36890;&#36807;&#22312;**Build Settings**&#20570;&#35832;&#22810;&#35774;&#32622;&#65292;&#24182;&#23558;Xcode&#20381;&#38468;&#21040;&#21478;&#19968;&#20010;Xcode&#23454;&#20307;&#19978;&#12290;&#24184;&#36816;&#30340;&#26159;&#65292;[@kattrali](witter.com/kattral)&#24050;&#32463;&#20026;&#20320;&#20570;&#20102;&#36825;&#20123;&#24037;&#20316;&#65292;&#24182;&#21487;&#36890;&#36807;&#27169;&#26495;&#21019;&#24314;&#25554;&#20214;&#12290;&#10;&#10;&#25214;&#21040;**Window\Package Manager**&#33756;&#21333;&#65292;&#25171;&#24320;**Alcatraz**&#25554;&#20214;&#12290;&#22312;Alcatraz&#25628;&#32034;&#26694;&#20013;&#65292;&#25628;&#32034;**Xcode Plugin**&#12290;&#30830;&#20445;&#25628;&#32034;&#31383;&#21475;&#30340;**All**&#21644;**Templates**&#23646;&#24615;&#34987;&#36873;&#20013;&#12290;&#19968;&#26086;&#25214;&#21040;Xcode&#30340;&#25554;&#20214;&#27169;&#26495;&#65292;&#28857;&#20987;&#23427;&#24038;&#36793;&#30340;&#23433;&#35013;&#25353;&#38062;&#65306;&#10;![](http://cdn2.raywenderlich.com/wp-content/uploads/2015/05/XcodeAlcatrazPlugin-700x208.png)&#10;&#10;&#19968;&#26086;Alcatraz&#19979;&#36733;&#25554;&#20214;&#23436;&#25104;&#65292;&#23601;&#21487;&#20197;&#36890;&#36807;&#33756;&#21333;**File\New\Project...**&#21019;&#24314;&#26032;&#21151;&#33021;&#65292;&#36873;&#25321;&#26032;&#24314;**OS X\Xcode Plugin\Xcode Plugin**&#27169;&#26495;&#36873;&#39033;&#65292;&#24182;&#28857;&#20987;**Next**&#12290;&#10;![](http://cdn3.raywenderlich.com/wp-content/uploads/2015/05/XcodePluginSelection-480x282.png)&#10;&#20135;&#21697;&#30340;&#21517;&#23383;&#35774;&#20026;&#8220;Rayrolling&#8221;&#65292;&#35774;&#32622;&#32452;&#32455;&#35782;&#21035;&#30721;&#20026;**com.raywenderlich**&#65288;&#36825;&#24456;&#37325;&#35201;&#65289;&#65292;&#24182;&#36873;&#25321;**Objective-C**&#20316;&#20026;&#24320;&#21457;&#35821;&#35328;&#65292;&#20445;&#23384;&#24037;&#31243;&#21040;&#20219;&#20309;&#20320;&#24819;&#35201;&#30340;&#30446;&#24405;&#20013;&#12290;&#10;![](http://cdn1.raywenderlich.com/wp-content/uploads/2015/05/Plugin_Xcode_Setup-480x281.png)    &#10;&#10;&#10;&#10;## Hello World&#25554;&#20214;&#27169;&#26495;&#10;&#10;&#32534;&#35793;&#24182;&#36816;&#34892;&#26032;&#30340;Rayrool&#24037;&#31243;&#65292;&#20320;&#20250;&#30475;&#21040;&#19968;&#20010;&#26032;&#30340;Xcode**&#23376;**&#23454;&#20307;&#12290;&#36825;&#20010;&#23376;&#23454;&#20307;&#22312;**Edit**&#33756;&#21333;&#37324;&#20250;&#20986;&#29616;&#21517;&#20026;**Do Action**&#30340;&#26032;&#36873;&#39033;&#65306;&#10;![](http://cdn1.raywenderlich.com/wp-content/uploads/2015/02/XcodePluginHelloWorld.png)&#10;&#10;&#36873;&#25321;&#35813;&#33756;&#21333;&#39033;&#20250;&#21551;&#21160;&#19968;&#20010;&#27169;&#24335;&#23545;&#35805;&#26694;&#65306;&#10;![](http://cdn3.raywenderlich.com/wp-content/uploads/2015/05/Screen-Shot-2015-05-11-at-8.48.27-PM.png)&#10;&#10;&#25554;&#20214;&#34987;&#26631;&#23450;&#22312;&#29305;&#23450;&#29256;&#26412;&#30340;Xcode&#20013;&#36816;&#34892;&#65292;&#24847;&#21619;&#30528;&#24403;&#26032;&#29256;&#26412;&#30340;Xcode&#20986;&#29616;&#65292;&#25152;&#26377;&#30340;&#31038;&#21306;&#21046;&#20316;&#30340;&#31532;&#19977;&#26041;&#25554;&#20214;&#37117;&#20250;&#22833;&#25928;&#65292;&#30452;&#21040;&#28155;&#21152;&#35813;&#29256;&#26412;&#29305;&#23450;&#30340;UUID&#12290;&#22914;&#26524;&#20010;&#21035;&#27169;&#26495;&#26080;&#27861;&#27491;&#24120;&#24037;&#20316;&#65292;&#24182;&#19988;&#20063;&#30475;&#19981;&#21040;&#26032;&#33756;&#21333;&#39033;&#65292;&#21487;&#33021;&#28155;&#21152;&#23545;&#35813;&#29256;&#26412;Xcode&#30340;&#25903;&#25345;&#12290;&#10;&#22312;**&#32456;&#31471;**&#20013;&#36816;&#34892;&#22914;&#19979;&#21629;&#20196;&#65306;</span><br></pre></td></tr></table></figure></span>
</code></pre><p>defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这条命令会输出你目前所使用的Xcode的UUID。打开插件的<span class="keyword">*</span><span class="keyword">*</span>Info.plist<span class="keyword">*</span><span class="keyword">*</span>，并找到键名<span class="keyword">*</span><span class="keyword">*</span>DVTPlugInCompatibilityUUID<span class="keyword">*</span><span class="keyword">*</span>，将值添加到该数组中：</span><br><span class="line">![](http://cdn1.raywenderlich.com/wp-content/uploads/2015/05/DVTCompatibilityUUIDs.gif)</span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">*</span><span class="keyword">*</span>注意：<span class="keyword">*</span><span class="keyword">*</span>整片教程中，你将运行和修改已安装的插件。这将会改变Xcode的行为，并且有可能会是Xcode崩溃！如果你想禁用一个插件，你需要手动使用如下命令移除它：</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
<p>cd ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins/<br>rm -r Rayrolling.xcplugin/</p>
<blockquote>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">然后重启Xcode。</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查找可修改的特性</span></span><br><span class="line">想获取后台将会发生什么，一个基本的尝试和正确的方式是通过<span class="keyword">*</span>NSNotification observer<span class="keyword">*</span>，它监听着所有Xcode发生的事件。通过使用Xcode和监视这些被触发的通知，你将能够一窥底层的一些东西。</span><br><span class="line"></span><br><span class="line">打开<span class="keyword">*</span><span class="keyword">*</span>Rayrolling.m<span class="keyword">*</span><span class="keyword">*</span>，并将下面的属性添加到这个类中</span><br></pre></td></tr></table></figure>
</blockquote>
<p>@property (nonatomic, strong) NSMutableSet *notificationSet;<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这个<span class="keyword">*</span><span class="keyword">*</span>NSMutableSet<span class="keyword">*</span><span class="keyword">*</span>保存了所有Xcode控制台输出的<span class="keyword">*</span><span class="keyword">*</span>NSNotification<span class="keyword">*</span><span class="keyword">*</span>名称。下一步，在<span class="keyword">*</span><span class="keyword">*</span>if (self = [super init]) &#123;<span class="keyword">*</span><span class="keyword">*</span>这一行之后，增加<span class="keyword">*</span><span class="keyword">*</span>initWithBundle:<span class="keyword">*</span><span class="keyword">*</span>的相关代码：</span><br></pre></td></tr></table></figure></p>
<p>[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:nil object:nil];</p>
<p>self.notificationSet = [NSMutableSet new];<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="gherkin">参数<span class="keyword">*</span><span class="keyword">*</span>name<span class="keyword">*</span><span class="keyword">*</span>传nil，表明你想要监听Xcode分发的所有通知。</span><br><span class="line">现在来实现<span class="keyword">*</span><span class="keyword">*</span>handleNotification:<span class="keyword">*</span><span class="keyword">*</span>，如下所示：</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>(void)handleNotification:(NSNotification *)notification {<br>if (![self.notificationSet containsObject:notification.name]) {<br>  NSLog(@”%@, %@”, notification.name, [notification.object class]);<br>  [self.notificationSet addObject:notification.name];<br>}<br>}<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span>handleNotification:<span class="keyword">*</span><span class="keyword">*</span>检查这个通知的名字是否在<span class="keyword">*</span><span class="keyword">*</span>notificationSet<span class="keyword">*</span><span class="keyword">*</span>中；如果不在，打印出通知的<span class="keyword">*</span><span class="keyword">*</span>名字<span class="keyword">*</span><span class="keyword">*</span>和<span class="keyword">*</span><span class="keyword">*</span>类<span class="keyword">*</span><span class="keyword">*</span>，并将之添加到该集合之中。这样，每种被报告的通知你只会看到一次。</span><br><span class="line">接下来，查找并替换声明的新增行为菜单项，并更新其标题文字：</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>NSMenuItem *actionMenuItem = [[NSMenuItem alloc] initWithTitle:@”Reset Logger”<br> action:@selector(doMenuAction) keyEquivalent:@””];<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">对<span class="keyword">*</span><span class="keyword">*</span>NSMenuItem<span class="keyword">*</span><span class="keyword">*</span>标题的这次微小的修改，仅是让你了解点击菜单的动作会重置<span class="keyword">*</span><span class="keyword">*</span>NSNotificationset<span class="keyword">*</span><span class="keyword">*</span>。</span><br><span class="line">最后，替换<span class="keyword">*</span><span class="keyword">*</span>doMenuAction<span class="keyword">*</span><span class="keyword">*</span>的实现，代码如下：</span><br></pre></td></tr></table></figure></p>
<ul>
<li>(void)doMenuAction {<br>[self.notificationSet removeAllObjects];<br>}<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这个菜单项现在将重置<span class="keyword">*</span><span class="keyword">*</span>notificationSet<span class="keyword">*</span><span class="keyword">*</span>属性中的所有通知。这将让你在滤掉“控制台噪音”后，检查你想看的通知项。</span><br><span class="line"></span><br><span class="line">再一次编译并运行插件，以重新启动子Xcode。确保你清晰的区分开运行中的<span class="keyword">*</span><span class="keyword">*</span>父Xcode<span class="keyword">*</span><span class="keyword">*</span>和正在调试状态的<span class="keyword">*</span><span class="keyword">*</span>子Xcode<span class="keyword">*</span><span class="keyword">*</span>实例，因为父不会包含最新的插件更改，直到你重新启动Xcode将之载入内存。</span><br><span class="line">随便操作一下子Xcode：点击按钮，打开窗口，并浏览一下应用，在父Xcode控制台会监视到所有的这些通知。</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查找并观察编译状态提示</span></span><br><span class="line"></span><br><span class="line">既然你已经可以观察Xcode中被触发的<span class="keyword">*</span><span class="keyword">*</span>NSNotification<span class="keyword">*</span><span class="keyword">*</span>名称，你只需将注意与显示编译提示相关联的类上。</span><br><span class="line"></span><br><span class="line">启动Xcode插件。在子Xcode中，打开任何工程。确保已经激活通知——在Xcode设置里，激活他们，无论是编译成功和失败。再一次，确保你在更改的是子Xcode的设置。</span><br><span class="line">![](http://cdn1.raywenderlich.com/wp-content/uploads/2015/05/rayroll-bezel.png)</span><br><span class="line"></span><br><span class="line">使用被创建的<span class="keyword">*</span><span class="keyword">*</span>Reset Logger<span class="keyword">*</span><span class="keyword">*</span>菜单项重置<span class="keyword">*</span><span class="keyword">*</span>notificationSet<span class="keyword">*</span><span class="keyword">*</span>，并运行子Xcode工程。</span><br><span class="line"></span><br><span class="line">在子Xcode编译成功（或者失败）是，注意控制台里的信息。略读控制台信息，看看是否相关的内容。你是否能进一步瞧出值得查看的通知项？以下的方案可能会给你一点帮助。</span><br><span class="line"></span><br><span class="line">&gt; 内附方案:通过通知捕捉</span><br><span class="line">&gt; 有几项值得我们进一步观察：</span><br><span class="line">&gt;&gt;</span><br><span class="line">&gt;&gt; <span class="keyword">*</span> NSWindowWillOrderOffScreenNotification,DVTBezelAlertPanel</span><br><span class="line">&gt;&gt; <span class="keyword">*</span> NSWindowDidOrderOffScreenNotification,DVTBezelAlertPanel</span><br><span class="line">&gt;&gt; <span class="keyword">*</span> NSWindowDidOrderOffScreenAndFinishAnimatingNotification,DVTBezelAlertPanel</span><br><span class="line">&gt; ![](http://cdn5.raywenderlich.com/wp-content/uploads/2015/02/XcodeNotificationListeningSourceKitCrash.png)</span><br><span class="line"></span><br><span class="line">你可以从中选出一条，并且进一步探索它，看看能挖出什么信息。</span><br><span class="line">那么<span class="keyword">*</span><span class="keyword">*</span>NSWindowWillOrderOffScreenNotification<span class="keyword">*</span><span class="keyword">*</span>怎么样？好主意！探索一下它。</span><br><span class="line">仍旧是<span class="keyword">*</span><span class="keyword">*</span>Rayrolled.m<span class="keyword">*</span><span class="keyword">*</span>，找到<span class="keyword">*</span><span class="keyword">*</span>handleNotification:<span class="keyword">*</span><span class="keyword">*</span>，并且在第一行增加断点，如图所示，之后的几步如下：</span><br><span class="line">![](http://cdn3.raywenderlich.com/wp-content/uploads/2015/04/Xcode_Add_Symbolic_Breakpoint.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 在断点处，右击断点，选择<span class="keyword">*</span><span class="keyword">*</span>Edit Breakpoint<span class="keyword">*</span><span class="keyword">*</span>；</span><br><span class="line">2. 在条件区域，粘贴<span class="keyword">*</span><span class="keyword">*</span>[notification.name isEqualToString:<span class="comment">@"NSWindowWillOrderOffScreenNotification"]**；</span></span><br><span class="line">3. 在<span class="keyword">*</span><span class="keyword">*</span>Action<span class="keyword">*</span><span class="keyword">*</span>区域，增加<span class="keyword">*</span><span class="keyword">*</span>po notification.object<span class="keyword">*</span><span class="keyword">*</span>；</span><br><span class="line">4. 如果父Xcode没有在运行子Xcode，那么启动编译器，然后在子Xcode中开始编译。断点就会在<span class="keyword">*</span><span class="keyword">*</span>NSWindowWillOrderOffScreenNotification<span class="keyword">*</span><span class="keyword">*</span>通知处起作用。观察<span class="keyword">*</span><span class="keyword">*</span>-[notification object]<span class="keyword">*</span><span class="keyword">*</span>的打印输出。这是<span class="keyword">*</span><span class="keyword">*</span>DVTBezelAlertPanel<span class="keyword">*</span><span class="keyword">*</span>，是你将要探索的诸多私有类中的第一个。</span><br><span class="line"></span><br><span class="line">现在开了一好头，你知道一个名为<span class="keyword">*</span><span class="keyword">*</span>DVTBezelAlertPanel<span class="keyword">*</span><span class="keyword">*</span>的类，并且更重要的是，你有这个类在内存中的实体。而不幸的是，你没有它的头文件，来确定这个实体是否负责显示Xcode的提示。</span><br><span class="line"></span><br><span class="line">事实上，获得这个信息是可能的。尽管你没有这个类的头文件，但你的确连接到子Xcode的调试器，并且头文件能告诉你的，内存同样也可以告诉你。</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">*</span><span class="keyword">*</span>注意：<span class="keyword">*</span><span class="keyword">*</span>对于这套教程，LLDB控制台的输出经常会包括控制台输入。以<span class="keyword">*</span><span class="keyword">*</span>(lldb)<span class="keyword">*</span><span class="keyword">*</span>开头的行可认为是控制台输入，并且也可以输入。三点...符号输出已从控制台的标准输出里忽略掉了。如果控制台中的巨量信息让你招架不住，按<span class="keyword">*</span><span class="keyword">*</span>⌘ + K<span class="keyword">*</span><span class="keyword">*</span>可以移除当前的内容，可回归到开始的清爽界面。</span><br><span class="line"></span><br><span class="line">当父Xcode调试器在断点处停止时，在它的LLDB控制台输入以下命令：</span><br><span class="line">&gt; (lldb) image lookup -rn DVTBezelAlertPanel</span><br><span class="line">&gt; 17 matches found in /Application/Xcode.app/Contents/SharedFrameworks/DVTKit.framework/Versions/A/DVTKit:...</span><br><span class="line"></span><br><span class="line">在Xcode内对<span class="keyword">*</span><span class="keyword">*</span>DVTBezelAlertPanel<span class="keyword">*</span><span class="keyword">*</span>的搜索，同样会在Xcode进程载入的框架、库和插件里搜索，并且会输出匹配的内容。看一下函数列表。在<span class="keyword">*</span><span class="keyword">*</span>DVTBezelAlertPanel<span class="keyword">*</span><span class="keyword">*</span>图片转储过程中是否有函数将这个类和错误信息联系起来？下面的帮助可供参考。</span><br><span class="line"></span><br><span class="line">&gt; 解决方案：相关函数</span><br><span class="line">&gt; <span class="keyword">*</span><span class="keyword">*</span>DVTBezelAlertPanel<span class="keyword">*</span><span class="keyword">*</span>相关函数看起来可以做进一步研究：</span><br><span class="line">&gt;&gt; <span class="keyword">*</span> <span class="keyword">*</span><span class="keyword">*</span>initWithIcon:message:parentWindow:duration<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">&gt;&gt; <span class="keyword">*</span> <span class="keyword">*</span><span class="keyword">*</span>initWithIcon:message:controlView:duration:<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">&gt;&gt; <span class="keyword">*</span> <span class="keyword">*</span><span class="keyword">*</span>controlView<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">&gt; 也许跳出上面两个初始化函数中的一个可以验证你是否跟踪到正确的提示框信息相关的类。</span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">*</span><span class="keyword">*</span>注意：<span class="keyword">*</span><span class="keyword">*</span>要知道<span class="keyword">*</span><span class="keyword">*</span>image lookup<span class="keyword">*</span><span class="keyword">*</span>的LLDB命令将列出内存中被执行的方法。当将此操作应用到一个特别的类上时，会忽略掉该类从其父类继承的方法。也就是说，该命令的搜索将忽略掉任何只在父类声明的方法，这些方法也不包括子类重载其父类的方法。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LLDB控制台无输出时，以如下命令查看<span class="keyword">*</span><span class="keyword">*</span>contentView<span class="keyword">*</span><span class="keyword">*</span>属性：</span><br><span class="line"></span><br><span class="line">&gt; (lldb) po [notification.object controlView]</span><br><span class="line">&gt; <span class="variable">&lt;nil&amp;gt;</span><br><span class="line"></span><br><span class="line">控制台返回**nil**。讨厌。也许是因为**controlView**此时没有被赋值。是时候采取不同的策略了。</span><br><span class="line">**initWithIcon:message:parentWindow:duration**和**initWithIcon:message:controlView:duration:**看似有点~~多汁~~。因为你知道**DVTBezelAlertPanel**实体目前还在，所以一定是这两个傻呆呆的方法中的一个执行过。你需要通过LLDB控制台在这两个函数处设个断点，然后再次出发这个类的初始化。</span><br><span class="line"></span><br><span class="line">在程序暂停时，在LLDB控制台中输入以下命令：</span><br><span class="line">&gt;</span> (lldb) rb 'DVTBezelAlertPanel\ initWithIcon:message:'</span><br><span class="line">&gt; Breakpoint 1: 2 locations.</span><br><span class="line">&gt; (lldb) br l</span><br><span class="line">&gt; ...</span><br><span class="line"></span><br><span class="line">这是一个正则表达式，它可以在上面的两句<span class="keyword">*</span><span class="keyword">*</span>DVTBezelAlertPanel<span class="keyword">*</span><span class="keyword">*</span>初始化处均设置上断点。因为两个初始化方法文字有相同的部分，这个表达式对他们都能匹配。确保在空格前有个“\”，并且命令被单引号包括，这样LLDB才知道如何正确的解析此表达式。</span><br><span class="line"></span><br><span class="line">恢复子程序的运行，然后重新编译子工程。编译器的断点将在<span class="keyword">*</span><span class="keyword">*</span>initWithIcon:message:parentWindow:duration<span class="keyword">*</span><span class="keyword">*</span>处停止。</span><br><span class="line">如果没有停住，确保父Xcode增加了断点，且子Xcode执行了工程。由于断点处的方法没有对应的源码文件，所以Xcode会在该函数的汇编码中暂停。</span><br><span class="line"></span><br><span class="line">由于你找到的函数没有源码文件，那么你需要开动脑筋想办法打印出传入该方法的参数。所以，我们是时候讨论一下<span class="keyword">*</span><span class="keyword">*</span>汇编<span class="keyword">*</span><span class="keyword">*</span>了！</span><br><span class="line">![](http://cdn5.raywenderlich.com/wp-content/uploads/2015/03/AssemblyRage.png)</span><br><span class="line"></span><br><span class="line"><span class="comment">##了解汇编的快速捷径</span></span><br><span class="line">在运行私有API时，你需要观察<span class="keyword">*</span><span class="keyword">*</span>寄存器<span class="keyword">*</span><span class="keyword">*</span>，而不是像在调试源代码时所用的调试标识符。知道寄存器在<span class="keyword">*</span><span class="keyword">*</span>x86-64<span class="keyword">*</span><span class="keyword">*</span>架构上的使用机制是有着巨大帮助的。</span><br><span class="line"></span><br><span class="line">尽管这不是必读内容，[这篇文章](https://mikeash.com/pyblog/friday-qa-2011-12-16-disassembling-the-assembly-part-1.html)是一篇补充x86 Mach-0平台汇编的优秀资源。在我们这套教程的第3部分，将会通过反汇编剖析一个方法，来看看正在执行什么，但不是现在，你将走一条更好走的路。</span><br><span class="line"></span><br><span class="line">需要标明一下各个寄存器是什么和是做什么的：</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span> <span class="keyword">*</span><span class="keyword">*</span>$rdi:<span class="keyword">*</span><span class="keyword">*</span>该寄存器引用了传入函数的<span class="keyword">*</span><span class="keyword">*</span>self<span class="keyword">*</span><span class="keyword">*</span>参数，是第一个被传入的参数。</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span> <span class="keyword">*</span><span class="keyword">*</span>$rsi:<span class="keyword">*</span><span class="keyword">*</span>引用的<span class="keyword">*</span><span class="keyword">*</span>Selector<span class="keyword">*</span><span class="keyword">*</span>参数，这是第二个参数。</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span> <span class="keyword">*</span><span class="keyword">*</span>$rdx:<span class="keyword">*</span><span class="keyword">*</span>传入函数的第三个参数，和Objective-C函数的第一个参数。</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span> <span class="keyword">*</span><span class="keyword">*</span>$rcx:<span class="keyword">*</span><span class="keyword">*</span>传入函数的第四个参数，和Objective-C函数的第二个参数。</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span> <span class="keyword">*</span><span class="keyword">*</span>$r8:<span class="keyword">*</span><span class="keyword">*</span>传入函数的第五个参数。如果函数还有参数，<span class="keyword">*</span><span class="keyword">*</span>$r9<span class="keyword">*</span><span class="keyword">*</span>是参数栈结构里的第六个参数。</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span> <span class="keyword">*</span><span class="keyword">*</span>$rax:<span class="keyword">*</span><span class="keyword">*</span>返回值被存入该寄存器。例如，当跳出<span class="keyword">*</span><span class="keyword">*</span>-[aClass description]<span class="keyword">*</span><span class="keyword">*</span>，在<span class="keyword">*</span><span class="keyword">*</span>$rax<span class="keyword">*</span><span class="keyword">*</span>里会有一个<span class="keyword">*</span><span class="keyword">*</span>NSString<span class="keyword">*</span><span class="keyword">*</span>类型的关于<span class="keyword">*</span><span class="keyword">*</span>aClass<span class="keyword">*</span><span class="keyword">*</span>实体的描述。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">*</span><span class="keyword">*</span>注意：<span class="keyword">*</span><span class="keyword">*</span>上面的讲述在一些情况下是不对的。有时二进制会针对不同的函数参数类型使用不同的寄存器，比如<span class="keyword">*</span><span class="keyword">*</span>doubles<span class="keyword">*</span><span class="keyword">*</span>则使用<span class="keyword">*</span><span class="keyword">*</span>$xmm<span class="keyword">*</span><span class="keyword">*</span>寄存器。所以，以上仅可作为参考。</span><br><span class="line"></span><br><span class="line">将这些理论实践一下，看看下面这个函数。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>@interface aClass : NSObject<br>-(NSString <em>)aMethodWithMessage:(NSString </em>)message；<br>@end</p>
<p>@implementation aClass<br>-(NSString <em>)aMethodWithMessage:(NSString </em>)message {<br>    return [NSString stringWithFormat:@”Hey the message is: %@”,message]<br>}<br>@end<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这样调用：</span><br></pre></td></tr></table></figure></p>
<p>aClass *aClassInstance = [[aClass alloc] init];<br>[aClassInstance aMethodWithMessage:@”Hello World”];<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">编译时，**<span class="attribute">aMethodWithMessage</span>:**会被传入**objc_msgSend**，看起来大概像这样：</span><br><span class="line"></span><br><span class="line"><span class="built_in">``</span>` <span class="function">objc_msgSend</span>(aClassInstance, <span class="variable">@selector</span>(<span class="attribute">aMethodWithMessage</span>:), @<span class="string">"Hello World"</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>aClass</strong>实体的<strong>aMethodWithMessage:</strong>函数会将如下结果写入这一系列的寄存器<br><strong>一旦调用aMethodWithMessage:</strong></p>
<ul>
<li><strong>$rdi:</strong>存储一个<strong>aClass</strong>实体。</li>
<li><strong>$rsi:</strong>存储了选择器<strong>aMethodWithMessage</strong>，它其实是个<strong>char *</strong>（在lldb中试一下<strong>po (SEL)$rsi</strong>）</li>
<li><strong>$rdx:</strong>存储了<strong>message</strong>内容，它引用了<strong>@”Hello World”的实体。
</strong>离开函数时**</li>
<li><strong>$rax:</strong>存储返回值，它是一个<strong>NSString</strong>实体。在这个例子中，它是@”Hey the message is:Hello World”的实体。<blockquote>
<p>译者注：本文主案例最新断点处如果输入<br>po $rcx<br>将会看到 Build Succeeded</p>
</blockquote>
</li>
</ul>
<h2 id="深入x86寄存器暂储机制">深入x86寄存器暂储机制</h2><p>既然你已是一名专业的汇编寄存器向导，那么现在重新访问<strong>DVTBezelAlertPanel</strong>的<strong>initWithIcon:message:parentWindow:duration:</strong>。希望你还没从这个函数的断点上移开。如果你这么做了，那么重新运行子Xcode。再次提醒，你正在寻找一个类的线索，它负责为显示Xcode编译成功提示。</p>
<p>在断点<strong>initWithIcon:message:parentWindow:duration</strong>处停止后，在LLDB输入如下：</p>
<figure class="highlight"><figcaption><span>re re```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;&#36825;&#26465;&#21629;&#20196;&#26159;**&#35835;&#23492;&#23384;&#22120;(register read)**&#30340;&#32553;&#20889;&#65292;&#23558;&#25171;&#21360;&#20986;&#26426;&#22120;&#20013;&#19968;&#20123;&#21487;&#29992;&#30340;&#24456;&#37325;&#35201;&#30340;&#23492;&#23384;&#22120;&#12290;&#10;&#10;&#29992;&#20320;&#24050;&#32463;&#23398;&#21040;&#30340;&#35835;0x86_64&#23492;&#23384;&#22120;&#30693;&#35782;&#65292;&#26816;&#26597;&#21442;&#25968;**message:**&#25152;&#23646;&#30340;&#23492;&#23384;&#22120;&#65292;&#21644;&#31532;&#22235;&#20010;objc_msgSend&#21442;&#25968;&#12290;&#20869;&#23481;&#26159;&#21542;&#19982;&#25552;&#31034;&#23383;&#31526;&#20018;&#30456;&#31526;&#65311;&#10;&#10;&#62; &#26041;&#27861;&#22914;&#19979;&#65306;&#10;&#10;&#62; &#26159;&#30340;&#65292;&#26597;&#30475;**$rcx**&#23492;&#23384;&#22120;&#65292;&#21487;&#20197;&#30475;&#21040;&#19982;&#32534;&#35793;&#25552;&#31034;&#23545;&#24212;&#30340;**message**&#21442;&#25968;&#12290;&#10;&#10;&#62; &#22312;**LLDB&#25511;&#21046;&#21488;**&#36755;&#20837;&#22914;&#19979;&#65292;&#36827;&#19968;&#27493;&#25506;&#32034;&#65306;&#10;&#10;&#62;&#62; (lldb) po $rcx&#10;&#10;&#62;&#62; Build Failed&#10;&#10;&#62;&#62;&#62; **&#27880;&#24847;&#65306;**Xcode&#20250;&#25171;&#21360;&#20986;**AT&#38;T**&#39118;&#26684;&#30340;&#27719;&#32534;&#12290;&#20805;&#20998;&#20102;&#35299;&#24403;&#21069;&#30340;&#39118;&#26684;&#65292;&#22240;&#20026;&#28304;&#25805;&#20316;&#23545;&#35937;&#21644;&#30446;&#30340;&#25805;&#20316;&#23545;&#35937;&#20250;&#34987;&#20132;&#25442;&#12290;&#10;&#10;&#62; &#30475;&#65292;&#36825;&#23601;&#26159;&#8220;&#20803;&#20982;&#8221;&#12290;&#10;&#10;&#10;&#10;&#32473;&#21442;&#25968;**$rcx**&#23492;&#23384;&#22120;&#20889;&#20837;&#19968;&#20010;&#26032;&#23383;&#31526;&#20018;&#65292;&#30475;&#30475;&#25552;&#31034;&#26694;&#26159;&#21542;&#25913;&#21464;&#23601;&#21487;&#20197;100%&#30830;&#23450;&#20102;&#65306;&#10;&#10;&#10;&#10;&#62; (lldb) po [$rcx class]&#10;&#10;&#62; __NSCFConstantString               &#10;&#10;&#10;&#10;&#62; (lldb) po id $a = @&#34;Womp womp!&#34;;&#10;&#10;&#62; (lldb) p/x $a&#10;&#10;&#62; (id) $a = 0x000061800203faa0&#10;&#10;&#62; (lldb) re w $rcx 0x000061800203faa0&#10;&#10;&#62; (lldb) c&#10;&#10;&#65279;&#10;&#10;![](http://cdn4.raywenderlich.com/wp-content/uploads/2015/04/Womp_Womp_Xcode.png)&#10;&#10;&#31243;&#24207;&#24674;&#22797;&#36816;&#34892;&#65292;&#27880;&#24847;&#35843;&#35797;&#22120;&#30340;&#25552;&#31034;&#20449;&#24687;&#24050;&#32463;&#25913;&#21464;&#12290;&#29616;&#22312;&#20320;&#21487;&#20197;&#23433;&#20840;&#30340;&#25512;&#26029;&#20986;&#36825;&#20010;&#31867;&#19982;&#32534;&#35793;&#25552;&#31034;&#30456;&#20851;&#32852;&#20102;&#12290;&#24050;&#32463;&#21021;&#38706;&#31471;&#20522;&#65292;&#23545;&#19981;&#23545;&#65311;&#10;&#10;## &#20195;&#30721;&#27880;&#20837;&#10;&#10;&#20320;&#24050;&#32463;&#25214;&#21040;&#20102;&#30456;&#20851;&#30340;&#31867;&#12290;&#29616;&#22312;&#21487;&#20197;&#22312;&#32534;&#35793;&#25552;&#31034;&#26174;&#31034;&#26102;&#65292;&#36890;&#36807;&#20195;&#30721;&#27880;&#20837;&#23558;&#21442;&#25968;**DVTBezelAlertPanel**&#30340;&#25552;&#31034;&#22270;&#29255;&#26367;&#25442;&#20026;&#19968;&#24352;Rayrolling&#30340;&#33804;&#29031;&#12290;&#10;&#10;&#37027;&#20040;[method swizzling](http://nshipster.com/method-swizzling/)&#35813;&#19978;&#22330;&#20102;&#65281;&#10;&#10;&#22240;&#20026;&#20320;&#21487;&#33021;&#35201;swizzle&#19981;&#21516;&#31867;&#30340;&#25968;&#20010;&#20989;&#25968;&#65292;&#25152;&#20197;&#26368;&#22909;&#29992;**NSObject**&#30340;**Category**&#21019;&#24314;&#19968;&#20010;&#26041;&#27861;&#20197;&#26041;&#20415;&#36827;&#34892;&#36923;&#36753;&#26500;&#24314;&#12290;&#10;&#10;&#36873;&#25321;**File\New\File...**&#65292;&#24182;&#36873;&#25321;**OS X\Source\Objective-C File**&#27169;&#26495;&#12290;&#21629;&#21517;&#20026;**MethodSwizzler**&#24182;&#35774;&#32622;&#25991;&#20214;&#31867;&#22411;&#20026;**Category**&#21644;&#31867;NSObject&#12290;&#10;&#25171;&#24320;**NSObject+MethodSwizzler.m**&#65292;&#24182;&#23558;&#20854;&#20869;&#23481;&#26367;&#25442;&#20026;&#22914;&#19979;&#20195;&#30721;:</span><br></pre></td></tr></table></figure>
<h1 id="import_“NSObject+MethodSwizzler-h”">import “NSObject+MethodSwizzler.h”</h1><p>// 1</p>
<h1 id="import">import <objc runtime.h=""></objc></h1><p>@implementation NSObject (MethodSwizzler)</p>
<ul>
<li><p>(void)swizzleWithOriginalSelector:(SEL)originalSelector swizzledSelector:(SEL) swizzledSelector isClassMethod:(BOOL)isClassMethod<br>{<br>Class cls = [self class];</p>
<p>Method originalMethod;<br>Method swizzledMethod;</p>
<p>// 2<br>if (isClassMethod) {<br>  originalMethod = class_getClassMethod(cls, originalSelector);<br>  swizzledMethod = class_getClassMethod(cls, swizzledSelector);<br>} else {<br>  originalMethod = class_getInstanceMethod(cls, originalSelector);<br>  swizzledMethod = class_getInstanceMethod(cls, swizzledSelector);<br>}</p>
<p>// 3<br>if (!originalMethod) {<br>  NSLog(@”Error: originalMethod is nil, did you spell it incorrectly? %@”, originalMethod);<br>  return;<br>}</p>
<p>// 4<br>method_exchangeImplementations(originalMethod, swizzledMethod);<br>}<br>@end</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">带编号的注释含义依次为：</span><br><span class="line"></span><br><span class="line">1. 这个神奇的头文件是负责声明用于method swizzling的函数。</span><br><span class="line">2. <span class="keyword">*</span><span class="keyword">*</span>isClassMethod<span class="keyword">*</span><span class="keyword">*</span>用以判断这些方法是类方法，还是实例方法。</span><br><span class="line">3. 当你不需要编译器帮忙自动编译方法时，很容易拼错方法名。这一步是检查以确保所声明的SEL准确无误。</span><br><span class="line">4. 这个函数会切换到你的实现部分。</span><br><span class="line"></span><br><span class="line">在<span class="keyword">*</span><span class="keyword">*</span>NSObject+MethodSwizzler.h<span class="keyword">*</span><span class="keyword">*</span>中声明<span class="keyword">*</span><span class="keyword">*</span>swizzleWithOriginalSelector:swizzledSelector:isClassMethod<span class="keyword">*</span><span class="keyword">*</span>方式如下：</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="import-1">import <foundation foundation.h=""></foundation></h1><p>@interface NSObject (MethodSwizzler)</p>
<ul>
<li>(void)swizzleWithOriginalSelector:(SEL)originalSelector swizzledSelector:(SEL) swizzledSelector isClassMethod:(BOOL)isClassMethod;</li>
</ul>
<p>@end<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">现在就可以真的swizzle了！创建另一个<span class="keyword">*</span><span class="keyword">*</span>Category<span class="keyword">*</span><span class="keyword">*</span>并命名为<span class="keyword">*</span><span class="keyword">*</span>Rayrolling_DVTBezelAlertPanel<span class="keyword">*</span><span class="keyword">*</span>，它继承自<span class="keyword">*</span><span class="keyword">*</span>NSObject<span class="keyword">*</span><span class="keyword">*</span>。</span><br><span class="line"></span><br><span class="line">以如下代码替换<span class="keyword">*</span><span class="keyword">*</span>NSObject+Rayrolling_DVTBezelAlertPanel.m<span class="keyword">*</span><span class="keyword">*</span>里的内容：</span><br></pre></td></tr></table></figure></p>
<h1 id="import_“NSObject+Rayrolling_DVTBezelAlertPanel-h”">import “NSObject+Rayrolling_DVTBezelAlertPanel.h”</h1><p>// 1</p>
<h1 id="import_“NSObject+MethodSwizzler-h”-1">import “NSObject+MethodSwizzler.h”</h1><h1 id="import-2">import <cocoa cocoa.h=""></cocoa></h1><p>// 2<br>@interface NSObject ()</p>
<p>// 3</p>
<ul>
<li>(id)initWithIcon:(id)arg1 message:(id)arg2 parentWindow:(id)arg3 duration:(double)arg4;<br>@end</li>
</ul>
<p>// 4<br>@implementation NSObject (Rayrolling_DVTBezelAlertPanel)</p>
<p>// 5</p>
<ul>
<li><p>(void)load<br>{<br>static dispatch_once_t onceToken;</p>
<p>// 6<br>dispatch_once(&amp;onceToken, ^{</p>
<p>  // 7<br>  [NSClassFromString(@”DVTBezelAlertPanel”) swizzleWithOriginalSelector:@selector(initWithIcon:message:parentWindow:duration:) swizzledSelector:@selector(Rayrolling_initWithIcon:message:parentWindow:duration:) isClassMethod:NO];<br>});<br>}</p>
</li>
</ul>
<p>// 8</p>
<ul>
<li><p>(id)Rayrolling_initWithIcon:(id)icon message:(id)message parentWindow:(id)window duration:(double)duration<br>{<br>// 9<br>NSLog(@”Swizzle success! %@”, self);</p>
<p>// 10<br>return [self Rayrolling_initWithIcon:icon message:message parentWindow:window duration:duration];<br>}</p>
</li>
</ul>
<p>@end<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">代码相对的简单明了，解释如下：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>确保导入要swizzling的方法。</span><br><span class="line"><span class="bullet">2. </span>你可以在此声明所有要用到的函数。尽管这不是必要的，但这可以让编译器更好的自动编译你的代码。另外，这个技巧可抑制未声明函数的警告。</span><br><span class="line"><span class="bullet">3. </span>这就是你将要swizzling的私有方法。</span><br><span class="line"><span class="bullet">4. </span>因为你不想重新声明一个私有类，你可以用分类(category)代替。</span><br><span class="line"><span class="bullet">5. </span>这是代码注入“伎俩”的核心。你将在<span class="strong">**load**</span>执行注入。<span class="strong">**load**</span>函数是唯一的，它里面有~~一对多的关系~~。也就是说，同一个类的多个分组都可在一个<span class="strong">**load**</span>命令里实现，并执行他们。</span><br><span class="line"><span class="bullet">6. </span>由于<span class="strong">**load**</span>会被调用多次，所以需要使用<span class="strong">**dispatch_once**</span>。</span><br><span class="line"><span class="bullet">7. </span>此处使用的是你之前实现过的<span class="strong">**NSObject**</span>分类方法。注意，你使用的是<span class="strong">**NSClassFromString**</span>来动态检索运行时的私有类。</span><br><span class="line"><span class="bullet">8. </span>此处是替代原来的函数。使用一个只有你自己可以规定的唯一命名空间约定，这是一个很好的做法。</span><br><span class="line"><span class="bullet">9. </span>此处是测试swizzling能否成功，将字符打印到控制台。</span><br><span class="line"><span class="bullet">10. </span>由于你正在swizzle原来的函数，所以当你调用被swizzle的函数时，仍然会调用原来的。这就意味着你可以在原来的方法被调用前后添加一些代码，甚至更改传入的参数...这个一会儿将要用到。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">恭喜你！你已经成功的将代码注入到一个私有类的私有方法！编译父Xcode，然后编译子Xcode，看看添加控制台的信息是否被swizzle进去了。</span><br><span class="line"></span><br><span class="line">现在可以使用Rayrolling的照片替换掉所有编译提示图片了。从[<span class="link_label">这里</span>](<span class="link_url">http://cdn2.raywenderlich.com/wp-content/uploads/2015/04/IDEAlertBezel_Generic_Rayrolling.pdf</span>)下载要swizzle的[<span class="link_label">Crispy</span>](<span class="link_url">http://www.raywenderlich.com/about#cbelanger</span>)的玉照，并将它写入Xcode工程。确保选择上<span class="strong">**Copy Items if Needed**</span>。</span><br><span class="line"></span><br><span class="line">回到<span class="strong">**Rayrolliing_initWithIcon:message:parentWindow:duration**</span>并将其内容更改如下：</span><br></pre></td></tr></table></figure></p>
<ul>
<li>(id)Rayrolling_initWithIcon:(id)arg1 message:(id)arg2 parentWindow:(id)arg3 duration:(double)arg4<br>{<br>if (arg1) {<br>  NSBundle <em>bundle = [NSBundle bundleWithIdentifier:@”com.raywenderlich.Rayrolling”];<br>  NSImage </em>newImage = [bundle imageForResource:@”IDEAlertBezel_Generic_Rayrolling.pdf”];<br>  return [self Rayrolling_initWithIcon:newImage message:arg2 parentWindow:arg3 duration:arg4];<br>}<br>return [self Rayrolling_initWithIcon:arg1 message:arg2 parentWindow:arg3 duration:arg4];<br>}<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">这个函数检查图片是否被传入原来的函数，并将其替换为Rayrolling的图片。需要注意的是你必须要用<span class="keyword">*</span><span class="keyword">*</span>+[NSBundle bundleWithIdentifier:]载入图片，因为它并没存储在你的<span class="keyword">*</span><span class="keyword">*</span>mainBundle<span class="keyword">*</span><span class="keyword">*</span>。</span><br><span class="line">编译并运行工程，退出所有的Xcode实体，重启。</span><br><span class="line">完美！:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 切换和持久化“雷摇摆”（Rayroll）</span></span><br><span class="line"></span><br><span class="line">你正设计的这个插件也许会惹人烦，很可能你更想让其可以在打开或者关闭状态之间切换，而可以使用<span class="keyword">*</span><span class="keyword">*</span>NSUserDefaults<span class="keyword">*</span><span class="keyword">*</span>来持久化Xcode的各种实体状态。</span><br><span class="line"></span><br><span class="line">回到<span class="keyword">*</span><span class="keyword">*</span>Rayrolling.h<span class="string">""</span>，并将如下属性添加到这个头文件：</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>(BOOL)isEnabled;</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">到<span class="keyword">*</span><span class="keyword">*</span>Rayrolling.m<span class="keyword">*</span><span class="keyword">*</span>，并添加如下函数：</span><br></pre></td></tr></table></figure>
</li>
<li><p>(BOOL)isEnabled {<br>return [[NSUserDefaults standardUserDefaults] boolForKey:@”com.raywenderlich.Rayrolling.shouldbeEnable”];<br>}</p>
</li>
<li><p>(void)setIsEnabled:(BOOL)shouldBeEnabled {<br>[[NSUserDefaults standardUserDefaults] setBool:shouldBeEnabled forKey:@”com.raywenderlich.Rayrolling.shouldbeEnable”];<br>}</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">你已经有了持久化你的选择的相关逻辑，现在需要在界面上添加个切换开关。</span><br><span class="line">回到<span class="keyword">*</span><span class="keyword">*</span>Rayrolling.m<span class="keyword">*</span><span class="keyword">*</span>，编辑<span class="keyword">*</span>-(void) doMenuAction<span class="keyword">*</span><span class="keyword">*</span>，代码如下：</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>(void)doMenuAction:(NSMenuItem *)menuItem {<br>[Rayrolling setIsEnabled:![Rayrolling isEnabled]];<br>menuItem.title = [Rayrolling isEnabled] ? @”Disable Rayrolling” : @”Enable Rayrolling”;<br>}<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这简单实现了切换激活和禁止<span class="string">"Rayrolling"</span>的功能。</span><br><span class="line">最后，在<span class="keyword">*</span><span class="keyword">*</span>didApplicationFinishLaunchingNotification:<span class="keyword">*</span><span class="keyword">*</span>里菜单设置代码，如下：</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>NSMenuItem <em>menuItem = [[NSApp mainMenu] itemWithTitle:@”Edit”];<br>if (menuItem) {<br>  [[menuItem submenu] addItem:[NSMenuItem separatorItem]];<br>  NSString </em>title = [Rayrolling isEnabled] ? @”Disable Rayrolling” : @”Enable Rayrolling”;<br>  NSMenuItem *actionMenuItem = [[NSMenuItem alloc] initWithTitle:title action:@selector(doMenuAction:) keyEquivalent:@””];<br>  [actionMenuItem setTarget:self];<br>  [[menuItem submenu] addItem:actionMenuItem];<br>}<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">现在你有个菜单项，它会持久化Xcode启动状态，并记住打开或关闭此逻辑的设定。</span><br><span class="line">回到<span class="keyword">*</span><span class="keyword">*</span>NSObject+Rayrolling_DVTBezelAlertPanel.m<span class="keyword">*</span><span class="keyword">*</span>，并添加如下引用：</span><br></pre></td></tr></table></figure></p>
<h1 id="import_“Rayrolling-h”">import “Rayrolling.h”</h1><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最后，打开**<span class="constant">Rayrolling_initWithIcon</span><span class="symbol">:message</span><span class="symbol">:parentWindow</span><span class="symbol">:duration</span><span class="symbol">:**</span>，并将</span><br></pre></td></tr></table></figure>
<p>if (arg1) {<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">替换为</span><br></pre></td></tr></table></figure></p>
<p>if ([Rayrolling isEnabled] &amp;&amp; arg1) {<br>```</p>
<p>编译并运行程序，这个变化对你的插件会有一定的宣传作用。<br>Boom!你现在已经拥有可以编辑Xcode提示，并可以打开和关掉的插件。今天完美收工，是不是？</p>
<h2 id="接下来，做什么？">接下来，做什么？</h2><p>你可以从这里下载本教程的<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2015/05/Rayrolling_Part1_Final.zip" target="_blank" rel="external">完整Rayrolling工程</a>。</p>
<p>虽然你已经有了不少的进展，但是仍然有很多东西要做？在第2部分，你将学习动态跟踪（Dtrace）和探索一些LLDB的高阶特性的基础，可以深入的观察到Xcode正运行的进程。</p>
<p>如果你想预习一些知识，在第3部分前有一些作业，里面有不少汇编代码。现在可通过阅读Mike Ash的关于反汇编的<a href="https://www.mikeash.com/pyblog/friday-qa-2011-12-16-disassembling-the-assembly-part-1.html" target="_blank" rel="external">第1部分</a>和<a href="https://www.mikeash.com/pyblog/friday-qa-2011-12-23-disassembling-the-assembly-part-2.html" target="_blank" rel="external">第2部分</a>文章，来学习和补充一些X86_64的汇编知识。这两篇文章对理解接下来的内容很有帮助。</p>
<p>好运吧，祝愉快！如果你关于本教程有任何的意见和问题，请在<a href="http://www.raywenderlich.com/94020/creating-an-xcode-plugin-part-1" target="_blank" rel="external">下面</a>留言。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/02/13/如何制作Xcode插件：1-3/" data-id="cikkrqzog0001zp058mr3aafq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2015/06/04/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/02/13/如何制作Xcode插件：1-3/">如何制作Xcode插件：1/3</a>
          </li>
        
          <li>
            <a href="/2015/06/04/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>