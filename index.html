<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="q" value="site:http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-[如何制作Xcode插件：1-3](http:--http:--www.raywenderlich.com-94020-creating-an-xcode-plugin-part-1)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/13/[如何制作Xcode插件：1-3](http:--http:--www.raywenderlich.com-94020-creating-an-xcode-plugin-part-1)/" class="article-date">
  <time datetime="2016-02-13T06:14:56.000Z" itemprop="datePublished">2016-02-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="如何制作Xcode插件：1/3"><a href="http://http://www.raywenderlich.com/94020/creating-an-xcode-plugin-part-1" target="_blank" rel="external">如何制作Xcode插件：1/3</a></h1><p>译者注：在学习写xcode插件的过程中，找了一些资料，其中<a href="http://www.raywenderlich.com" target="_blank" rel="external">www.raywenderlich.com</a>中的三篇文章写得很好，这是其中的第一篇《<a href="http://http://www.raywenderlich.com/94020/creating-an-xcode-plugin-part-1" target="_blank" rel="external">How To Create an Xcode Plugin:Part1/3 </a>》。</p>
<hr>
<p><strong>更新备注：</strong>这篇教程只用Xcode6.3.2测试过——如果你使用的其他版本的Xcode，那么你的经历可能会与这篇教程中的有一定出入。</p>
<p>苹果公司针对扩展其产品的“一刀切”的规则就像让人强吞下一颗难以忍受的药丸。尽管目前苹果公司强制iOS或者OS X平台的开发者使用它的工作流程，但是仍然可以通过制作插件的方式使Xcode更为适用。</p>
<p>这不是关于如何制作Xcode插件的苹果公司官方文档，但是开发社区已经做了数量惊人的工作致力于帮助让开发者拥有更为有效的工具。</p>
<p>从<a href="https://github.com/ksuther/KSImageNamed-Xcode" target="_blank" rel="external">autocompletion for images</a>，到nuking你的<a href="https://github.com/kattrali/deriveddata-exterminator" target="_blank" rel="external">Derived Data</a>，再到<a href="https://github.com/XVimProject/XVim" target="_blank" rel="external">vim editor</a>，Xcode插件社区已经推动了原本被认为可以推动的边界。</p>
<p>在这史诗般的三篇教程中，你将制作一款Xcode插件来恶搞你的搭档，而主演恶搞者的人没有一人比他更爱恶作剧——Ray本人。虽然这些插件看似轻松搞笑，但是你仍然可以从中学习到许多通过Xcode跟踪，如何找到你想要修改的元素，以及如何swizzle进你自己的函数。</p>
<p>你将会查阅一些未公开的框架，会用到如下技术：<a href="https://www.mikeash.com/pyblog/friday-qa-2011-12-16-disassembling-the-assembly-part-1.html" target="_blank" rel="external">X86汇编知识</a>，<a href="http://www.raywenderlich.com/79600/navigating-a-new-codebase" target="_blank" rel="external">源码的导航技巧</a>和在探索私有API和用<a href="http://nshipster.com/method-swizzling/" target="_blank" rel="external">method swizzling</a>做代码注入的<a href="http://www.raywenderlich.com/?s=lldb" target="_blank" rel="external">LLDB技术</a> 。由于会涉及到的方方面面较多，所以这篇教程会进行的较快。那么，在开始之前确保你的iOS或OS X平台在最佳状态吧！</p>
<p>使用Swift进行插件开发会严重复杂化这个原本就已经很棘手的题目，况且Swift调试工具相较于Objectvie-C的仍然有所不足。所以现在，(在这篇教程中)开发插件最好的选择是Objective-C。</p>
<hr>
<h2 id="开始">开始</h2><p>为了庆祝“恶搞搭档日”，你的Xcode插件将“瑞克摇摆”为你的牺牲者。稍等，什么是“瑞克摇摆”？它是免费版本的<a href="https://en.wikipedia.org/wiki/Rickrolling" target="_blank" rel="external">“瑞克摇摆”</a>的版权和版税，就是将牺牲者替换到大家原本预期会出现的内容里。当你完成后，插件将Xcode变成下面的样子：</p>
<ol>
<li><p>将Ray的脸蛋植入到Xcode的通知中（例如：编译成功或失败）。<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/04/Xcode_Swizzle_DispalAlert.png" alt=""></p>
</li>
<li><p>将Ray流行一时的歌曲植入到标题栏内，<strong>永不放弃你</strong>。<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/05/Plugin_Swizzled_Titlebar.png" alt=""></p>
</li>
<li><p>将所有Xcode文档请求都重置到<a href="https://www.youtube.com/watch?v=ce-_0opZzh0" target="_blank" rel="external">“瑞克摇摆”的录像</a><br><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/04/Plugin_Swizzle_Documentation-700x288.png" alt=""></p>
</li>
</ol>
<p>在教程的第一部分，你们将集中精力一路跟踪到负责显示“编译完成”通知的类，并将其修改为Ray的一张大头照。</p>
<h2 id="安装Alcatraz插件">安装Alcatraz插件</h2><p>在做任何事之前，都应该先安装<a href="http://alcatraz.io/" target="_blank" rel="external">Alcatraz</a>。Alcatraz是Xcode插件的管家，它的作者是天才的开发者<a href="https://twitter.com/kattrali" target="_blank" rel="external">@kattrali</a>，<a href="https://twitter.com/_supermarin" target="_blank" rel="external">@_supermarin</a>和<a href="https://twitter.com/JurreTweet" target="_blank" rel="external">@jurreTweet</a>。</p>
<p>安装Alcatraz，在终端上执行如下命令：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL http<span class="variable">s:</span>//raw.github.<span class="keyword">com</span>/supermarin/Alcatraz/master/Scripts/install.<span class="keyword">sh</span> | <span class="keyword">sh</span></span><br></pre></td></tr></table></figure>
<p>脚本执行完成后，重启Xcode。会看到Alcatraz bundle的如下提示框；点击<strong>Load Bundle</strong>。你一定想要更强力的Xcode，对不对？<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/05/Xcode6.3.2.png" alt=""></p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">*</span><span class="keyword">*</span>注意<span class="keyword">*</span><span class="keyword">*</span>：如果你不小心点击了“Skip Bundle”，可以通过在终端里执行如下命令再次开启这个提示框：</span><br><span class="line"></span><br><span class="line">defaults delete com.apple.dt.Xcode DVTPlugInManagerNonApplePlugIns-Xcode-6.3.2</span><br></pre></td></tr></table></figure>
<p>在Xcode的<strong>Window</strong>菜单会出现一个名为<strong>Package Manager</strong>的新选项。制作Xcode插件要通过在<strong>Build Settings</strong>做诸多设置，并将Xcode依附到另一个Xcode实体上。幸运的是，<a href="witter.com/kattral">@kattrali</a>已经为你做了这些工作，并可通过模板创建插件。</p>
<p>找到<strong>Window\Package Manager</strong>菜单，打开<strong>Alcatraz</strong>插件。在Alcatraz搜索框中，搜索<strong>Xcode Plugin</strong>。确保搜索窗口的<strong>All</strong>和<strong>Templates</strong>属性被选中。一旦找到Xcode的插件模板，点击它左边的安装按钮：<br><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/05/XcodeAlcatrazPlugin-700x208.png" alt=""></p>
<p>一旦Alcatraz下载插件完成，就可以通过菜单<strong>File\New\Project…</strong>创建新功能，选择新建<strong>OS X\Xcode Plugin\Xcode Plugin</strong>模板选项，并点击<strong>Next</strong>。<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/05/XcodePluginSelection-480x282.png" alt=""><br>产品的名字设为“Rayrolling”，设置组织识别码为<strong>com.raywenderlich</strong>（这很重要），并选择<strong>Objective-C</strong>作为开发语言，保存工程到任何你想要的目录中。<br><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/05/Plugin_Xcode_Setup-480x281.png" alt="">    </p>
<h2 id="Hello_World插件模板">Hello World插件模板</h2><p>编译并运行新的Rayrool工程，你会看到一个新的Xcode<strong>子</strong>实体。这个子实体在<strong>Edit</strong>菜单里会出现名为<strong>Do Action</strong>的新选项：<br><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/02/XcodePluginHelloWorld.png" alt=""></p>
<p>选择该菜单项会启动一个模式对话框：<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/05/Screen-Shot-2015-05-11-at-8.48.27-PM.png" alt=""></p>
<p>插件被标定在特定版本的Xcode中运行，意味着当新版本的Xcode出现，所有的社区制作的第三方插件都会失效，直到添加该版本特定的UUID。如果个别模板无法正常工作，并且也看不到新菜单项，可能添加对该版本Xcode的支持。<br>在<strong>终端</strong>中运行如下命令：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults <span class="keyword">read</span> <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/I</span>nfo DVTPlugInCompatibilityUUID</span><br></pre></td></tr></table></figure>
<p>这条命令会输出你目前所使用的Xcode的UUID。打开插件的<strong>Info.plist</strong>，并找到键名<strong>DVTPlugInCompatibilityUUID</strong>，将值添加到该数组中：<br><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/05/DVTCompatibilityUUIDs.gif" alt=""></p>
<blockquote>
<p><strong>注意：</strong>整片教程中，你将运行和修改已安装的插件。这将会改变Xcode的行为，并且有可能会是Xcode崩溃！如果你想禁用一个插件，你需要手动使用如下命令移除它：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">~/Library/</span>Application\ Support<span class="regexp">/Developer/</span>Shared<span class="regexp">/Xcode/</span>Plug-ins/</span><br><span class="line">rm -r Rayrolling.xcplugin/</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后重启Xcode。</p>
<h2 id="查找可修改的特性">查找可修改的特性</h2><p>想获取后台将会发生什么，一个基本的尝试和正确的方式是通过<em>NSNotification observer</em>，它监听着所有Xcode发生的事件。通过使用Xcode和监视这些被触发的通知，你将能够一窥底层的一些东西。</p>
<p>打开<strong>Rayrolling.m</strong>，并将下面的属性添加到这个类中</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableSet</span> *notificationSet;</span><br></pre></td></tr></table></figure>
<p>这个<strong>NSMutableSet</strong>保存了所有Xcode控制台输出的<strong>NSNotification</strong>名称。下一步，在<strong>if (self = [super init]) {</strong>这一行之后，增加<strong>initWithBundle:</strong>的相关代码：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter] <span class="string">addObserver:</span>self <span class="string">selector:</span><span class="annotation">@selector</span>(<span class="string">handleNotification:</span>) <span class="string">name:</span>nil <span class="string">object:</span>nil];</span><br><span class="line"></span><br><span class="line">self.notificationSet = [NSMutableSet <span class="keyword">new</span>];</span><br></pre></td></tr></table></figure>
<p>参数<strong>name</strong>传nil，表明你想要监听Xcode分发的所有通知。<br>现在来实现<strong>handleNotification:</strong>，如下所示：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)handleNotification:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">  <span class="keyword">if</span> (![<span class="keyword">self</span><span class="variable">.notificationSet</span> containsObject:notification<span class="variable">.name</span>]) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@, %@"</span>, notification<span class="variable">.name</span>, [notification<span class="variable">.object</span> class]);</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.notificationSet</span> addObject:notification<span class="variable">.name</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>handleNotification:</strong>检查这个通知的名字是否在<strong>notificationSet</strong>中；如果不在，打印出通知的<strong>名字</strong>和<strong>类</strong>，并将之添加到该集合之中。这样，每种被报告的通知你只会看到一次。<br>接下来，查找并替换声明的新增行为菜单项，并更新其标题文字：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSMenuItem *actionMenuItem = [[NSMenuItem alloc] <span class="string">initWithTitle:</span>@<span class="string">"Reset Logger"</span></span><br><span class="line"><span class="label"> action:</span><span class="annotation">@selector</span>(doMenuAction) <span class="string">keyEquivalent:</span>@<span class="string">""</span>];</span><br></pre></td></tr></table></figure>
<p>对<strong>NSMenuItem</strong>标题的这次微小的修改，仅是让你了解点击菜单的动作会重置<strong>NSNotificationset</strong>。<br>最后，替换<strong>doMenuAction</strong>的实现，代码如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (void)<span class="tag">doMenuAction</span> &#123;</span><br><span class="line">  <span class="attr_selector">[self.notificationSet removeAllObjects]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个菜单项现在将重置<strong>notificationSet</strong>属性中的所有通知。这将让你在滤掉“控制台噪音”后，检查你想看的通知项。</p>
<p>再一次编译并运行插件，以重新启动子Xcode。确保你清晰的区分开运行中的<strong>父Xcode</strong>和正在调试状态的<strong>子Xcode</strong>实例，因为父不会包含最新的插件更改，直到你重新启动Xcode将之载入内存。<br>随便操作一下子Xcode：点击按钮，打开窗口，并浏览一下应用，在父Xcode控制台会监视到所有的这些通知。</p>
<h2 id="查找并观察编译状态提示">查找并观察编译状态提示</h2><p>既然你已经可以观察Xcode中被触发的<strong>NSNotification</strong>名称，你只需将注意与显示编译提示相关联的类上。</p>
<p>启动Xcode插件。在子Xcode中，打开任何工程。确保已经激活通知——在Xcode设置里，激活他们，无论是编译成功和失败。再一次，确保你在更改的是子Xcode的设置。<br><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/05/rayroll-bezel.png" alt=""></p>
<p>使用被创建的<strong>Reset Logger</strong>菜单项重置<strong>notificationSet</strong>，并运行子Xcode工程。</p>
<p>在子Xcode编译成功（或者失败）是，注意控制台里的信息。略读控制台信息，看看是否相关的内容。你是否能进一步瞧出值得查看的通知项？以下的方案可能会给你一点帮助。</p>
<blockquote>
<p>内附方案:通过通知捕捉<br>有几项值得我们进一步观察：<br>&gt;</p>
<blockquote>
<ul>
<li>NSWindowWillOrderOffScreenNotification,DVTBezelAlertPanel</li>
<li>NSWindowDidOrderOffScreenNotification,DVTBezelAlertPanel</li>
<li>NSWindowDidOrderOffScreenAndFinishAnimatingNotification,DVTBezelAlertPanel<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/02/XcodeNotificationListeningSourceKitCrash.png" alt=""></li>
</ul>
</blockquote>
</blockquote>
<p>你可以从中选出一条，并且进一步探索它，看看能挖出什么信息。<br>那么<strong>NSWindowWillOrderOffScreenNotification</strong>怎么样？好主意！探索一下它。<br>仍旧是<strong>Rayrolled.m</strong>，找到<strong>handleNotification:</strong>，并且在第一行增加断点，如图所示，之后的几步如下：<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/04/Xcode_Add_Symbolic_Breakpoint.png" alt=""></p>
<ol>
<li>在断点处，右击断点，选择<strong>Edit Breakpoint</strong>；</li>
<li>在条件区域，粘贴<strong>[notification.name isEqualToString:@”NSWindowWillOrderOffScreenNotification”]</strong>；</li>
<li>在<strong>Action</strong>区域，增加<strong>po notification.object</strong>；</li>
<li>如果父Xcode没有在运行子Xcode，那么启动编译器，然后在子Xcode中开始编译。断点就会在<strong>NSWindowWillOrderOffScreenNotification</strong>通知处起作用。观察<strong>-[notification object]</strong>的打印输出。这是<strong>DVTBezelAlertPanel</strong>，是你将要探索的诸多私有类中的第一个。</li>
</ol>
<p>现在开了一好头，你知道一个名为<strong>DVTBezelAlertPanel</strong>的类，并且更重要的是，你有这个类在内存中的实体。而不幸的是，你没有它的头文件，来确定这个实体是否负责显示Xcode的提示。</p>
<p>事实上，获得这个信息是可能的。尽管你没有这个类的头文件，但你的确连接到子Xcode的调试器，并且头文件能告诉你的，内存同样也可以告诉你。</p>
<blockquote>
<p><strong>注意：</strong>对于这套教程，LLDB控制台的输出经常会包括控制台输入。以<strong>(lldb)</strong>开头的行可认为是控制台输入，并且也可以输入。三点…符号输出已从控制台的标准输出里忽略掉了。如果控制台中的巨量信息让你招架不住，按<strong>⌘ + K</strong>可以移除当前的内容，可回归到开始的清爽界面。</p>
</blockquote>
<p>当父Xcode调试器在断点处停止时，在它的LLDB控制台输入以下命令：</p>
<blockquote>
<p>(lldb) image lookup -rn DVTBezelAlertPanel<br>17 matches found in /Application/Xcode.app/Contents/SharedFrameworks/DVTKit.framework/Versions/A/DVTKit:…</p>
</blockquote>
<p>在Xcode内对<strong>DVTBezelAlertPanel</strong>的搜索，同样会在Xcode进程载入的框架、库和插件里搜索，并且会输出匹配的内容。看一下函数列表。在<strong>DVTBezelAlertPanel</strong>图片转储过程中是否有函数将这个类和错误信息联系起来？下面的帮助可供参考。</p>
<blockquote>
<p>解决方案：相关函数<br><strong>DVTBezelAlertPanel</strong>相关函数看起来可以做进一步研究：</p>
<blockquote>
<ul>
<li><strong>initWithIcon:message:parentWindow:duration</strong></li>
<li><strong>initWithIcon:message:controlView:duration:</strong></li>
<li><strong>controlView</strong><br>也许跳出上面两个初始化函数中的一个可以验证你是否跟踪到正确的提示框信息相关的类。</li>
</ul>
</blockquote>
<p><strong>注意：</strong>要知道<strong>image lookup</strong>的LLDB命令将列出内存中被执行的方法。当将此操作应用到一个特别的类上时，会忽略掉该类从其父类继承的方法。也就是说，该命令的搜索将忽略掉任何只在父类声明的方法，这些方法也不包括子类重载其父类的方法。</p>
</blockquote>
<p>LLDB控制台无输出时，以如下命令查看<strong>contentView</strong>属性：</p>
<blockquote>
<p>(lldb) po [notification.object controlView]</p>
<p>&lt;nil&gt; </p>
</blockquote>
<p>控制台返回<strong>nil</strong>。讨厌。也许是因为<strong>controlView</strong>此时没有被赋值。是时候采取不同的策略了。<br><strong>initWithIcon:message:parentWindow:duration</strong>和<strong>initWithIcon:message:controlView:duration:</strong>看似有点<del>多汁</del>。因为你知道<strong>DVTBezelAlertPanel</strong>实体目前还在，所以一定是这两个傻呆呆的方法中的一个执行过。你需要通过LLDB控制台在这两个函数处设个断点，然后再次出发这个类的初始化。</p>
<p>在程序暂停时，在LLDB控制台中输入以下命令：</p>
<blockquote>
<p>(lldb) rb ‘DVTBezelAlertPanel\ initWithIcon:message:’<br>Breakpoint 1: 2 locations.<br>(lldb) br l<br>…</p>
</blockquote>
<p>这是一个正则表达式，它可以在上面的两句<strong>DVTBezelAlertPanel</strong>初始化处均设置上断点。因为两个初始化方法文字有相同的部分，这个表达式对他们都能匹配。确保在空格前有个“\”，并且命令被单引号包括，这样LLDB才知道如何正确的解析此表达式。</p>
<p>恢复子程序的运行，然后重新编译子工程。编译器的断点将在<strong>initWithIcon:message:parentWindow:duration</strong>处停止。<br>如果没有停住，确保父Xcode增加了断点，且子Xcode执行了工程。由于断点处的方法没有对应的源码文件，所以Xcode会在该函数的汇编码中暂停。</p>
<p>由于你找到的函数没有源码文件，那么你需要开动脑筋想办法打印出传入该方法的参数。所以，我们是时候讨论一下<strong>汇编</strong>了！<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/03/AssemblyRage.png" alt=""></p>
<h2 id="了解汇编的快速捷径">了解汇编的快速捷径</h2><p>在运行私有API时，你需要观察<strong>寄存器</strong>，而不是像在调试源代码时所用的调试标识符。知道寄存器在<strong>x86-64</strong>架构上的使用机制是有着巨大帮助的。</p>
<p>尽管这不是必读内容，<a href="https://mikeash.com/pyblog/friday-qa-2011-12-16-disassembling-the-assembly-part-1.html" target="_blank" rel="external">这篇文章</a>是一篇补充x86 Mach-0平台汇编的优秀资源。在我们这套教程的第3部分，将会通过反汇编剖析一个方法，来看看正在执行什么，但不是现在，你将走一条更好走的路。</p>
<p>需要标明一下各个寄存器是什么和是做什么的：</p>
<ul>
<li><p><strong>$rdi:</strong>该寄存器引用了传入函数的<strong>self</strong>参数，是第一个被传入的参数。</p>
</li>
<li><p><strong>$rsi:</strong>引用的<strong>Selector</strong>参数，这是第二个参数。</p>
</li>
<li><p><strong>$rdx:</strong>传入函数的第三个参数，和Objective-C函数的第一个参数。</p>
</li>
<li><p><strong>$rcx:</strong>传入函数的第四个参数，和Objective-C函数的第二个参数。</p>
</li>
<li><p><strong>$r8:</strong>传入函数的第五个参数。如果函数还有参数，<strong>$r9</strong>是参数栈结构里的第六个参数。</p>
</li>
<li><p><strong>$rax:</strong>返回值被存入该寄存器。例如，当跳出<strong>-[aClass description]</strong>，在<strong>$rax</strong>里会有一个<strong>NSString</strong>类型的关于<strong>aClass</strong>实体的描述。</p>
</li>
</ul>
<blockquote>
<p><strong>注意：</strong>上面的讲述在一些情况下是不对的。有时二进制会针对不同的函数参数类型使用不同的寄存器，比如<strong>doubles</strong>则使用<strong>$xmm</strong>寄存器。所以，以上仅可作为参考。</p>
</blockquote>
<p>将这些理论实践一下，看看下面这个函数。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">aClass</span> : <span class="title">NSObject</span></span></span><br><span class="line">-(<span class="built_in">NSString</span> *)aMethodWithMessage:(<span class="built_in">NSString</span> *)message；</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">aClass</span></span></span><br><span class="line">-(<span class="built_in">NSString</span> *)aMethodWithMessage:(<span class="built_in">NSString</span> *)message &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Hey the message is: %@"</span>,message]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>这样调用：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">aClass</span> *<span class="atom">aClassInstance</span> = [[<span class="atom">aClass</span> <span class="atom">alloc</span>] <span class="atom">init</span>];</span><br><span class="line">[<span class="atom">aClassInstance</span> <span class="atom">aMethodWithMessage</span>:@<span class="string">"Hello World"</span>];</span><br></pre></td></tr></table></figure>
<p>编译时，<strong>aMethodWithMessage:</strong>会被传入<strong>objc_msgSend</strong>，看起来大概像这样：</p>
<figure class="highlight"><figcaption><span>@selector(aMethodWithMessage:), @"Hello World")```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;**aClass**&#23454;&#20307;&#30340;**aMethodWithMessage:**&#20989;&#25968;&#20250;&#23558;&#22914;&#19979;&#32467;&#26524;&#20889;&#20837;&#36825;&#19968;&#31995;&#21015;&#30340;&#23492;&#23384;&#22120;&#10;**&#19968;&#26086;&#35843;&#29992;aMethodWithMessage:**&#10;* **$rdi:**&#23384;&#20648;&#19968;&#20010;**aClass**&#23454;&#20307;&#12290;&#10;* **$rsi:**&#23384;&#20648;&#20102;&#36873;&#25321;&#22120;**aMethodWithMessage**&#65292;&#23427;&#20854;&#23454;&#26159;&#20010;**char ***&#65288;&#22312;lldb&#20013;&#35797;&#19968;&#19979;**po (SEL)$rsi**&#65289;&#10;* **$rdx:**&#23384;&#20648;&#20102;**message**&#20869;&#23481;&#65292;&#23427;&#24341;&#29992;&#20102;**@&#34;Hello World&#34;&#30340;&#23454;&#20307;&#12290;&#10;**&#31163;&#24320;&#20989;&#25968;&#26102;**&#10;* **$rax:**&#23384;&#20648;&#36820;&#22238;&#20540;&#65292;&#23427;&#26159;&#19968;&#20010;**NSString**&#23454;&#20307;&#12290;&#22312;&#36825;&#20010;&#20363;&#23376;&#20013;&#65292;&#23427;&#26159;@&#34;Hey the message is:Hello World&#34;&#30340;&#23454;&#20307;&#12290;&#10;&#62; &#35793;&#32773;&#27880;&#65306;&#26412;&#25991;&#20027;&#26696;&#20363;&#26368;&#26032;&#26029;&#28857;&#22788;&#22914;&#26524;&#36755;&#20837;&#10;&#62; po $rcx&#10;&#62; &#23558;&#20250;&#30475;&#21040; Build Succeeded&#10;&#10;## &#28145;&#20837;x86&#23492;&#23384;&#22120;&#26242;&#20648;&#26426;&#21046;&#10;&#10;&#26082;&#28982;&#20320;&#24050;&#26159;&#19968;&#21517;&#19987;&#19994;&#30340;&#27719;&#32534;&#23492;&#23384;&#22120;&#21521;&#23548;&#65292;&#37027;&#20040;&#29616;&#22312;&#37325;&#26032;&#35775;&#38382;**DVTBezelAlertPanel**&#30340;**initWithIcon:message:parentWindow:duration:**&#12290;&#24076;&#26395;&#20320;&#36824;&#27809;&#20174;&#36825;&#20010;&#20989;&#25968;&#30340;&#26029;&#28857;&#19978;&#31227;&#24320;&#12290;&#22914;&#26524;&#20320;&#36825;&#20040;&#20570;&#20102;&#65292;&#37027;&#20040;&#37325;&#26032;&#36816;&#34892;&#23376;Xcode&#12290;&#20877;&#27425;&#25552;&#37266;&#65292;&#20320;&#27491;&#22312;&#23547;&#25214;&#19968;&#20010;&#31867;&#30340;&#32447;&#32034;&#65292;&#23427;&#36127;&#36131;&#20026;&#26174;&#31034;Xcode&#32534;&#35793;&#25104;&#21151;&#25552;&#31034;&#12290;&#10;&#10;&#22312;&#26029;&#28857;**initWithIcon:message:parentWindow:duration**&#22788;&#20572;&#27490;&#21518;&#65292;&#22312;LLDB&#36755;&#20837;&#22914;&#19979;&#65306;&#10;&#10;```(lldb) re re</span><br></pre></td></tr></table></figure>
<p>这条命令是<strong>读寄存器(register read)</strong>的缩写，将打印出机器中一些可用的很重要的寄存器。</p>
<p>用你已经学到的读0x86_64寄存器知识，检查参数<strong>message:</strong>所属的寄存器，和第四个objc_msgSend参数。内容是否与提示字符串相符？</p>
<blockquote>
<p>方法如下：</p>
<p>是的，查看<strong>$rcx</strong>寄存器，可以看到与编译提示对应的<strong>message</strong>参数。</p>
<p>在<strong>LLDB控制台</strong>输入如下，进一步探索：</p>
<blockquote>
<p>(lldb) po $rcx</p>
<p>Build Failed</p>
<blockquote>
<p><strong>注意：</strong>Xcode会打印出<strong>AT&amp;T</strong>风格的汇编。充分了解当前的风格，因为源操作对象和目的操作对象会被交换。</p>
</blockquote>
</blockquote>
<p>看，这就是“元凶”。</p>
</blockquote>
<p>给参数<strong>$rcx</strong>寄存器写入一个新字符串，看看提示框是否改变就可以100%确定了：</p>
<blockquote>
<p>(lldb) po [$rcx class]</p>
<p>__NSCFConstantString               </p>
<p>(lldb) po id $a = @”Womp womp!”;</p>
<p>(lldb) p/x $a</p>
<p>(id) $a = 0x000061800203faa0</p>
<p>(lldb) re w $rcx 0x000061800203faa0</p>
<p>(lldb) c</p>
</blockquote>
<p>﻿</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/04/Womp_Womp_Xcode.png" alt=""></p>
<p>程序恢复运行，注意调试器的提示信息已经改变。现在你可以安全的推断出这个类与编译提示相关联了。已经初露端倪，对不对？</p>
<h2 id="代码注入">代码注入</h2><p>你已经找到了相关的类。现在可以在编译提示显示时，通过代码注入将参数<strong>DVTBezelAlertPanel</strong>的提示图片替换为一张Rayrolling的萌照。</p>
<p>那么<a href="http://nshipster.com/method-swizzling/" target="_blank" rel="external">method swizzling</a>该上场了！</p>
<p>因为你可能要swizzle不同类的数个函数，所以最好用<strong>NSObject</strong>的<strong>Category</strong>创建一个方法以方便进行逻辑构建。</p>
<p>选择<strong>File\New\File…</strong>，并选择<strong>OS X\Source\Objective-C File</strong>模板。命名为<strong>MethodSwizzler</strong>并设置文件类型为<strong>Category</strong>和类NSObject。<br>打开<strong>NSObject+MethodSwizzler.m</strong>，并将其内容替换为如下代码:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"NSObject+MethodSwizzler.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">MethodSwizzler</span>)</span></span><br><span class="line"> </span><br><span class="line">+ (<span class="keyword">void</span>)swizzleWithOriginalSelector:(SEL)originalSelector swizzledSelector:(SEL) swizzledSelector isClassMethod:(<span class="built_in">BOOL</span>)isClassMethod </span><br><span class="line">&#123;</span><br><span class="line">  Class cls = [<span class="keyword">self</span> class];</span><br><span class="line"> </span><br><span class="line">  Method originalMethod;</span><br><span class="line">  Method swizzledMethod;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">if</span> (isClassMethod) &#123;</span><br><span class="line">    originalMethod = class_getClassMethod(cls, originalSelector);</span><br><span class="line">    swizzledMethod = class_getClassMethod(cls, swizzledSelector);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    originalMethod = class_getInstanceMethod(cls, originalSelector);</span><br><span class="line">    swizzledMethod = class_getInstanceMethod(cls, swizzledSelector);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  <span class="keyword">if</span> (!originalMethod) &#123; </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Error: originalMethod is nil, did you spell it incorrectly? %@"</span>, originalMethod);</span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 4</span></span><br><span class="line">  method_exchangeImplementations(originalMethod, swizzledMethod); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>带编号的注释含义依次为：</p>
<ol>
<li>这个神奇的头文件是负责声明用于method swizzling的函数。</li>
<li><strong>isClassMethod</strong>用以判断这些方法是类方法，还是实例方法。</li>
<li>当你不需要编译器帮忙自动编译方法时，很容易拼错方法名。这一步是检查以确保所声明的SEL准确无误。</li>
<li>这个函数会切换到你的实现部分。</li>
</ol>
<p>在<strong>NSObject+MethodSwizzler.h</strong>中声明<strong>swizzleWithOriginalSelector:swizzledSelector:isClassMethod</strong>方式如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line"> </span><br><span class="line"><span class="annotation">@interface</span> NSObject (MethodSwizzler)</span><br><span class="line">+ (<span class="typename">void</span>)<span class="string">swizzleWithOriginalSelector:</span>(SEL)originalSelector <span class="string">swizzledSelector:</span>(SEL) swizzledSelector <span class="string">isClassMethod:</span>(BOOL)isClassMethod;</span><br><span class="line"> </span><br><span class="line"><span class="annotation">@end</span></span><br></pre></td></tr></table></figure>
<p>现在就可以真的swizzle了！创建另一个<strong>Category</strong>并命名为<strong>Rayrolling_DVTBezelAlertPanel</strong>，它继承自<strong>NSObject</strong>。</p>
<p>以如下代码替换<strong>NSObject+Rayrolling_DVTBezelAlertPanel.m</strong>里的内容：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> <span class="string">"NSObject+Rayrolling_DVTBezelAlertPanel.h"</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">#<span class="keyword">import</span> <span class="string">"NSObject+MethodSwizzler.h"</span></span><br><span class="line">#<span class="keyword">import</span> &lt;Cocoa/Cocoa.h&gt;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="annotation">@interface</span> NSObject ()</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">- (id)<span class="string">initWithIcon:</span>(id)arg1 <span class="string">message:</span>(id)arg2 <span class="string">parentWindow:</span>(id)arg3 <span class="string">duration:</span>(<span class="typename">double</span>)arg4;</span><br><span class="line"><span class="annotation">@end</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="annotation">@implementation</span> NSObject (Rayrolling_DVTBezelAlertPanel)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line">+ (<span class="typename">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static</span> dispatch_once_t onceToken;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 6</span></span><br><span class="line">  dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 7</span></span><br><span class="line">    [NSClassFromString(@<span class="string">"DVTBezelAlertPanel"</span>) <span class="string">swizzleWithOriginalSelector:</span><span class="annotation">@selector</span>(<span class="string">initWithIcon:</span><span class="string">message:</span><span class="string">parentWindow:</span><span class="string">duration:</span>) <span class="string">swizzledSelector:</span><span class="annotation">@selector</span>(<span class="string">Rayrolling_initWithIcon:</span><span class="string">message:</span><span class="string">parentWindow:</span><span class="string">duration:</span>) <span class="string">isClassMethod:</span>NO];</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line">- (id)<span class="string">Rayrolling_initWithIcon:</span>(id)icon <span class="string">message:</span>(id)message <span class="string">parentWindow:</span>(id)window <span class="string">duration:</span>(<span class="typename">double</span>)duration</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 9</span></span><br><span class="line">  NSLog(@<span class="string">"Swizzle success! %@"</span>, self);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 10</span></span><br><span class="line">  <span class="keyword">return</span> [self <span class="string">Rayrolling_initWithIcon:</span>icon <span class="string">message:</span>message <span class="string">parentWindow:</span>window <span class="string">duration:</span>duration];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="annotation">@end</span></span><br></pre></td></tr></table></figure>
<p>代码相对的简单明了，解释如下：</p>
<ol>
<li>确保导入要swizzling的方法。</li>
<li>你可以在此声明所有要用到的函数。尽管这不是必要的，但这可以让编译器更好的自动编译你的代码。另外，这个技巧可抑制未声明函数的警告。</li>
<li>这就是你将要swizzling的私有方法。</li>
<li>因为你不想重新声明一个私有类，你可以用分类(category)代替。</li>
<li>这是代码注入“伎俩”的核心。你将在<strong>load</strong>执行注入。<strong>load</strong>函数是唯一的，它里面有<del>一对多的关系</del>。也就是说，同一个类的多个分组都可在一个<strong>load</strong>命令里实现，并执行他们。</li>
<li>由于<strong>load</strong>会被调用多次，所以需要使用<strong>dispatch_once</strong>。</li>
<li>此处使用的是你之前实现过的<strong>NSObject</strong>分类方法。注意，你使用的是<strong>NSClassFromString</strong>来动态检索运行时的私有类。</li>
<li>此处是替代原来的函数。使用一个只有你自己可以规定的唯一命名空间约定，这是一个很好的做法。</li>
<li>此处是测试swizzling能否成功，将字符打印到控制台。</li>
<li>由于你正在swizzle原来的函数，所以当你调用被swizzle的函数时，仍然会调用原来的。这就意味着你可以在原来的方法被调用前后添加一些代码，甚至更改传入的参数…这个一会儿将要用到。</li>
</ol>
<p>恭喜你！你已经成功的将代码注入到一个私有类的私有方法！编译父Xcode，然后编译子Xcode，看看添加控制台的信息是否被swizzle进去了。</p>
<p>现在可以使用Rayrolling的照片替换掉所有编译提示图片了。从<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2015/04/IDEAlertBezel_Generic_Rayrolling.pdf" target="_blank" rel="external">这里</a>下载要swizzle的<a href="http://www.raywenderlich.com/about#cbelanger" target="_blank" rel="external">Crispy</a>的玉照，并将它写入Xcode工程。确保选择上<strong>Copy Items if Needed</strong>。</p>
<p>回到<strong>Rayrolliing_initWithIcon:message:parentWindow:duration</strong>并将其内容更改如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (id)<span class="string">Rayrolling_initWithIcon:</span>(id)arg1 <span class="string">message:</span>(id)arg2 <span class="string">parentWindow:</span>(id)arg3 <span class="string">duration:</span>(<span class="typename">double</span>)arg4 </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (arg1) &#123;  </span><br><span class="line">    NSBundle *bundle = [NSBundle <span class="string">bundleWithIdentifier:</span>@<span class="string">"com.raywenderlich.Rayrolling"</span>];</span><br><span class="line">    NSImage *newImage = [bundle <span class="string">imageForResource:</span>@<span class="string">"IDEAlertBezel_Generic_Rayrolling.pdf"</span>];</span><br><span class="line">    <span class="keyword">return</span> [self <span class="string">Rayrolling_initWithIcon:</span>newImage <span class="string">message:</span>arg2 <span class="string">parentWindow:</span>arg3 <span class="string">duration:</span>arg4];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [self <span class="string">Rayrolling_initWithIcon:</span>arg1 <span class="string">message:</span>arg2 <span class="string">parentWindow:</span>arg3 <span class="string">duration:</span>arg4];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数检查图片是否被传入原来的函数，并将其替换为Rayrolling的图片。需要注意的是你必须要用<strong>+[NSBundle bundleWithIdentifier:]载入图片，因为它并没存储在你的</strong>mainBundle**。<br>编译并运行工程，退出所有的Xcode实体，重启。<br>完美！:]</p>
<h2 id="切换和持久化“雷摇摆”（Rayroll）">切换和持久化“雷摇摆”（Rayroll）</h2><p>你正设计的这个插件也许会惹人烦，很可能你更想让其可以在打开或者关闭状态之间切换，而可以使用<strong>NSUserDefaults</strong>来持久化Xcode的各种实体状态。</p>
<p>回到**Rayrolling.h””，并将如下属性添加到这个头文件：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="list">(<span class="keyword">BOOL</span>)</span>isEnabled<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>到<strong>Rayrolling.m</strong>，并添加如下函数：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)isEnabled &#123;</span><br><span class="line">  <span class="keyword">return</span> [[NSUserDefaults standardUserDefaults] <span class="string">boolForKey:</span>@<span class="string">"com.raywenderlich.Rayrolling.shouldbeEnable"</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">+ (<span class="typename">void</span>)<span class="string">setIsEnabled:</span>(BOOL)shouldBeEnabled &#123;</span><br><span class="line">  [[NSUserDefaults standardUserDefaults] <span class="string">setBool:</span>shouldBeEnabled <span class="string">forKey:</span>@<span class="string">"com.raywenderlich.Rayrolling.shouldbeEnable"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你已经有了持久化你的选择的相关逻辑，现在需要在界面上添加个切换开关。<br>回到<strong>Rayrolling.m</strong>，编辑<em>-(void) doMenuAction*</em>，代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="typename">void</span>)<span class="string">doMenuAction:</span>(NSMenuItem *)menuItem &#123;</span><br><span class="line">  [Rayrolling <span class="string">setIsEnabled:</span>![Rayrolling isEnabled]];</span><br><span class="line">  menuItem.title = [Rayrolling isEnabled] ? @"Disable Rayrolling" : @<span class="string">"Enable Rayrolling"</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这简单实现了切换激活和禁止”Rayrolling”的功能。<br>最后，在<strong>didApplicationFinishLaunchingNotification:</strong>里菜单设置代码，如下：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="name">NSMenuItem</span> *<span class="atom">menuItem</span> = [[<span class="name">NSApp</span> <span class="atom">mainMenu</span>] <span class="atom">itemWithTitle</span>:@<span class="string">"Edit"</span>];</span><br><span class="line"><span class="atom">if</span> (<span class="atom">menuItem</span>) &#123;</span><br><span class="line">  [[<span class="atom">menuItem</span> <span class="atom">submenu</span>] <span class="atom">addItem</span>:[<span class="name">NSMenuItem</span> <span class="atom">separatorItem</span>]];</span><br><span class="line">  <span class="name">NSString</span> *<span class="atom">title</span> = [<span class="name">Rayrolling</span> <span class="atom">isEnabled</span>] ? @<span class="string">"Disable Rayrolling"</span> : @<span class="string">"Enable Rayrolling"</span>;</span><br><span class="line">  <span class="name">NSMenuItem</span> *<span class="atom">actionMenuItem</span> = [[<span class="name">NSMenuItem</span> <span class="atom">alloc</span>] <span class="atom">initWithTitle</span>:<span class="atom">title</span> <span class="atom">action</span>:@<span class="atom">selector</span>(<span class="atom">doMenuAction</span>:) <span class="atom">keyEquivalent</span>:@<span class="string">""</span>];</span><br><span class="line">  [<span class="atom">actionMenuItem</span> <span class="atom">setTarget</span>:<span class="atom">self</span>];</span><br><span class="line">  [[<span class="atom">menuItem</span> <span class="atom">submenu</span>] <span class="atom">addItem</span>:<span class="atom">actionMenuItem</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在你有个菜单项，它会持久化Xcode启动状态，并记住打开或关闭此逻辑的设定。<br>回到<strong>NSObject+Rayrolling_DVTBezelAlertPanel.m</strong>，并添加如下引用：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#import</span> <span class="string">"Rayrolling.h"</span></span><br></pre></td></tr></table></figure>
<p>最后，打开<strong>Rayrolling_initWithIcon:message:parentWindow:duration:</strong>，并将</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(arg1)</span> &#123;</span><br></pre></td></tr></table></figure>
<p>替换为</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">([Rayrolling isEnabled] &amp;&amp; arg1)</span> &#123;</span><br></pre></td></tr></table></figure>
<p>编译并运行程序，这个变化对你的插件会有一定的宣传作用。<br>Boom!你现在已经拥有可以编辑Xcode提示，并可以打开和关掉的插件。今天完美收工，是不是？</p>
<h2 id="接下来，做什么？">接下来，做什么？</h2><p>你可以从这里下载本教程的<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2015/05/Rayrolling_Part1_Final.zip" target="_blank" rel="external">完整Rayrolling工程</a>。</p>
<p>虽然你已经有了不少的进展，但是仍然有很多东西要做？在第2部分，你将学习动态跟踪（Dtrace）和探索一些LLDB的高阶特性的基础，可以深入的观察到Xcode正运行的进程。</p>
<p>如果你想预习一些知识，在第3部分前有一些作业，里面有不少汇编代码。现在可通过阅读Mike Ash的关于反汇编的<a href="https://www.mikeash.com/pyblog/friday-qa-2011-12-16-disassembling-the-assembly-part-1.html" target="_blank" rel="external">第1部分</a>和<a href="https://www.mikeash.com/pyblog/friday-qa-2011-12-23-disassembling-the-assembly-part-2.html" target="_blank" rel="external">第2部分</a>文章，来学习和补充一些X86_64的汇编知识。这两篇文章对理解接下来的内容很有帮助。</p>
<p>好运吧，祝愉快！如果你关于本教程有任何的意见和问题，请在<a href="http://www.raywenderlich.com/94020/creating-an-xcode-plugin-part-1" target="_blank" rel="external">下面</a>留言。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/02/13/[如何制作Xcode插件：1-3](http:--http:--www.raywenderlich.com-94020-creating-an-xcode-plugin-part-1)/" data-id="cikkqbf8a0000qr055wzazim9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-如何制作Xcode插件：1-3-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/13/如何制作Xcode插件：1-3-1/" class="article-date">
  <time datetime="2016-02-13T01:52:41.000Z" itemprop="datePublished">2016-02-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="如何制作Xcode插件：1/3">如何制作Xcode插件：1/3</h1><p>译者注：在学习写xcode插件的过程中，找了一些资料，其中<a href="www.raywenderlich.com">www.raywenderlich.com</a>中的三篇文章写得很好，这是其中的第一篇《<a href="http://http://www.raywenderlich.com/94020/creating-an-xcode-plugin-part-1" target="_blank" rel="external">How To Create an Xcode Plugin:Part1/3 </a>》。</p>
<hr>
<p><strong>更新备注：</strong>这篇教程只用Xcode6.3.2测试过——如果你使用的其他版本的Xcode，那么你的经历可能会与这篇教程中的有一定出入。</p>
<p>苹果公司针对扩展其产品的“一刀切”的规则就像让人强吞下一颗难以忍受的药丸。尽管目前苹果公司强制iOS或者OS X平台的开发者使用它的工作流程，但是仍然可以通过制作插件的方式使Xcode更为适用。</p>
<p>这不是关于如何制作Xcode插件的苹果公司官方文档，但是开发社区已经做了数量惊人的工作致力于帮助让开发者拥有更为有效的工具。</p>
<p>从<a href="https://github.com/ksuther/KSImageNamed-Xcode" target="_blank" rel="external">autocompletion for images</a>，到nuking你的<a href="https://github.com/kattrali/deriveddata-exterminator" target="_blank" rel="external">Derived Data</a>，再到<a href="https://github.com/XVimProject/XVim" target="_blank" rel="external">vim editor</a>，Xcode插件社区已经推动了原本被认为可以推动的边界。</p>
<p>在这史诗般的三篇教程中，你将制作一款Xcode插件来恶搞你的搭档，而主演恶搞者的人没有一人比他更爱恶作剧——Ray本人。虽然这些插件看似轻松搞笑，但是你仍然可以从中学习到许多通过Xcode跟踪，如何找到你想要修改的元素，以及如何swizzle进你自己的函数。</p>
<p>你将会查阅一些未公开的框架，会用到如下技术：<a href="https://www.mikeash.com/pyblog/friday-qa-2011-12-16-disassembling-the-assembly-part-1.html" target="_blank" rel="external">X86汇编知识</a>，<a href="http://www.raywenderlich.com/79600/navigating-a-new-codebase" target="_blank" rel="external">源码的导航技巧</a>和在探索私有API和用<a href="http://nshipster.com/method-swizzling/" target="_blank" rel="external">method swizzling</a>做代码注入的<a href="http://www.raywenderlich.com/?s=lldb" target="_blank" rel="external">LLDB技术</a> 。由于会涉及到的方方面面较多，所以这篇教程会进行的较快。那么，在开始之前确保你的iOS或OS X平台在最佳状态吧！</p>
<p>使用Swift进行插件开发会严重复杂化这个原本就已经很棘手的题目，况且Swift调试工具相较于Objectvie-C的仍然有所不足。所以现在，(在这篇教程中)开发插件最好的选择是Objective-C。</p>
<hr>
<h2 id="开始">开始</h2><p>为了庆祝“恶搞搭档日”，你的Xcode插件将“瑞克摇摆”为你的牺牲者。稍等，什么是“瑞克摇摆”？它是免费版本的<a href="https://en.wikipedia.org/wiki/Rickrolling" target="_blank" rel="external">“瑞克摇摆”</a>的版权和版税，就是将牺牲者替换到大家原本预期会出现的内容里。当你完成后，插件将Xcode变成下面的样子：</p>
<ol>
<li><p>将Ray的脸蛋植入到Xcode的通知中（例如：编译成功或失败）。<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/04/Xcode_Swizzle_DispalAlert.png" alt=""></p>
</li>
<li><p>将Ray流行一时的歌曲植入到标题栏内，<strong>永不放弃你</strong>。<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/05/Plugin_Swizzled_Titlebar.png" alt=""></p>
</li>
<li><p>将所有Xcode文档请求都重置到<a href="https://www.youtube.com/watch?v=ce-_0opZzh0" target="_blank" rel="external">“瑞克摇摆”的录像</a><br><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/04/Plugin_Swizzle_Documentation-700x288.png" alt=""></p>
</li>
</ol>
<p>在教程的第一部分，你们将集中精力一路跟踪到负责显示“编译完成”通知的类，并将其修改为Ray的一张大头照。</p>
<h2 id="安装Alcatraz插件">安装Alcatraz插件</h2><p>在做任何事之前，都应该先安装<a href="http://alcatraz.io/" target="_blank" rel="external">Alcatraz</a>。Alcatraz是Xcode插件的管家，它的作者是天才的开发者<a href="https://twitter.com/kattrali" target="_blank" rel="external">@kattrali</a>，<a href="https://twitter.com/_supermarin" target="_blank" rel="external">@_supermarin</a>和<a href="https://twitter.com/JurreTweet" target="_blank" rel="external">@jurreTweet</a>。</p>
<p>安装Alcatraz，在终端上执行如下命令：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL http<span class="variable">s:</span>//raw.github.<span class="keyword">com</span>/supermarin/Alcatraz/master/Scripts/install.<span class="keyword">sh</span> | <span class="keyword">sh</span></span><br></pre></td></tr></table></figure>
<p>脚本执行完成后，重启Xcode。会看到Alcatraz bundle的如下提示框；点击<strong>Load Bundle</strong>。你一定想要更强力的Xcode，对不对？<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/05/Xcode6.3.2.png" alt=""></p>
<blockquote>
<p><strong>注意</strong>：如果你不小心点击了“Skip Bundle”，可以通过在终端里执行如下命令再次开启这个提示框：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; defaults delete com<span class="class">.apple</span><span class="class">.dt</span><span class="class">.Xcode</span> DVTPlugInManagerNonApplePlugIns-Xcode-<span class="number">6.3</span>.<span class="number">2</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在Xcode的<strong>Window</strong>菜单会出现一个名为<strong>Package Manager</strong>的新选项。制作Xcode插件要通过在<strong>Build Settings</strong>做诸多设置，并将Xcode依附到另一个Xcode实体上。幸运的是，<a href="witter.com/kattral">@kattrali</a>已经为你做了这些工作，并可通过模板创建插件。</p>
<p>找到<strong>Window\Package Manager</strong>菜单，打开<strong>Alcatraz</strong>插件。在Alcatraz搜索框中，搜索<strong>Xcode Plugin</strong>。确保搜索窗口的<strong>All</strong>和<strong>Templates</strong>属性被选中。一旦找到Xcode的插件模板，点击它左边的安装按钮：<br><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/05/XcodeAlcatrazPlugin-700x208.png" alt=""></p>
<p>一旦Alcatraz下载插件完成，就可以通过菜单<strong>File\New\Project…</strong>创建新功能，选择新建<strong>OS X\Xcode Plugin\Xcode Plugin</strong>模板选项，并点击<strong>Next</strong>。<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/05/XcodePluginSelection-480x282.png" alt=""><br>产品的名字设为“Rayrolling”，设置组织识别码为<strong>com.raywenderlich</strong>（这很重要），并选择<strong>Objective-C</strong>作为开发语言，保存工程到任何你想要的目录中。<br><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/05/Plugin_Xcode_Setup-480x281.png" alt="">    </p>
<h2 id="Hello_World插件模板">Hello World插件模板</h2><p>编译并运行新的Rayrool工程，你会看到一个新的Xcode<strong>子</strong>实体。这个子实体在<strong>Edit</strong>菜单里会出现名为<strong>Do Action</strong>的新选项：<br><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/02/XcodePluginHelloWorld.png" alt=""></p>
<p>选择该菜单项会启动一个模式对话框：<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/05/Screen-Shot-2015-05-11-at-8.48.27-PM.png" alt=""></p>
<p>插件被标定在特定版本的Xcode中运行，意味着当新版本的Xcode出现，所有的社区制作的第三方插件都会失效，直到添加该版本特定的UUID。如果个别模板无法正常工作，并且也看不到新菜单项，可能添加对该版本Xcode的支持。<br>在<strong>终端</strong>中运行如下命令：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults <span class="keyword">read</span> <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/I</span>nfo DVTPlugInCompatibilityUUID</span><br></pre></td></tr></table></figure>
<p>这条命令会输出你目前所使用的Xcode的UUID。打开插件的<strong>Info.plist</strong>，并找到键名<strong>DVTPlugInCompatibilityUUID</strong>，将值添加到该数组中：<br><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/05/DVTCompatibilityUUIDs.gif" alt=""></p>
<blockquote>
<p><strong>注意：</strong>整片教程中，你将运行和修改已安装的插件。这将会改变Xcode的行为，并且有可能会是Xcode崩溃！如果你想禁用一个插件，你需要手动使用如下命令移除它：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">~/Library/</span>Application\ Support<span class="regexp">/Developer/</span>Shared<span class="regexp">/Xcode/</span>Plug-ins/</span><br><span class="line">rm -r Rayrolling.xcplugin/</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后重启Xcode。</p>
<h2 id="查找可修改的特性">查找可修改的特性</h2><p>想获取后台将会发生什么，一个基本的尝试和正确的方式是通过<em>NSNotification observer</em>，它监听着所有Xcode发生的事件。通过使用Xcode和监视这些被触发的通知，你将能够一窥底层的一些东西。</p>
<p>打开<strong>Rayrolling.m</strong>，并将下面的属性添加到这个类中</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableSet</span> *notificationSet;</span><br></pre></td></tr></table></figure>
<p>这个<strong>NSMutableSet</strong>保存了所有Xcode控制台输出的<strong>NSNotification</strong>名称。下一步，在<strong>if (self = [super init]) {</strong>这一行之后，增加<strong>initWithBundle:</strong>的相关代码：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter] <span class="string">addObserver:</span>self <span class="string">selector:</span><span class="annotation">@selector</span>(<span class="string">handleNotification:</span>) <span class="string">name:</span>nil <span class="string">object:</span>nil];</span><br><span class="line"></span><br><span class="line">self.notificationSet = [NSMutableSet <span class="keyword">new</span>];</span><br></pre></td></tr></table></figure>
<p>参数<strong>name</strong>传nil，表明你想要监听Xcode分发的所有通知。<br>现在来实现<strong>handleNotification:</strong>，如下所示：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)handleNotification:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">  <span class="keyword">if</span> (![<span class="keyword">self</span><span class="variable">.notificationSet</span> containsObject:notification<span class="variable">.name</span>]) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@, %@"</span>, notification<span class="variable">.name</span>, [notification<span class="variable">.object</span> class]);</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.notificationSet</span> addObject:notification<span class="variable">.name</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>handleNotification:</strong>检查这个通知的名字是否在<strong>notificationSet</strong>中；如果不在，打印出通知的<strong>名字</strong>和<strong>类</strong>，并将之添加到该集合之中。这样，每种被报告的通知你只会看到一次。<br>接下来，查找并替换声明的新增行为菜单项，并更新其标题文字：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSMenuItem *actionMenuItem = [[NSMenuItem alloc] <span class="string">initWithTitle:</span>@<span class="string">"Reset Logger"</span></span><br><span class="line"><span class="label"> action:</span><span class="annotation">@selector</span>(doMenuAction) <span class="string">keyEquivalent:</span>@<span class="string">""</span>];</span><br></pre></td></tr></table></figure>
<p>对<strong>NSMenuItem</strong>标题的这次微小的修改，仅是让你了解点击菜单的动作会重置<strong>NSNotificationset</strong>。<br>最后，替换<strong>doMenuAction</strong>的实现，代码如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (void)<span class="tag">doMenuAction</span> &#123;</span><br><span class="line">  <span class="attr_selector">[self.notificationSet removeAllObjects]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个菜单项现在将重置<strong>notificationSet</strong>属性中的所有通知。这将让你在滤掉“控制台噪音”后，检查你想看的通知项。</p>
<p>再一次编译并运行插件，以重新启动子Xcode。确保你清晰的区分开运行中的<strong>父Xcode</strong>和正在调试状态的<strong>子Xcode</strong>实例，因为父不会包含最新的插件更改，直到你重新启动Xcode将之载入内存。<br>随便操作一下子Xcode：点击按钮，打开窗口，并浏览一下应用，在父Xcode控制台会监视到所有的这些通知。</p>
<h2 id="查找并观察编译状态提示">查找并观察编译状态提示</h2><p>既然你已经可以观察Xcode中被触发的<strong>NSNotification</strong>名称，你只需将注意与显示编译提示相关联的类上。</p>
<p>启动Xcode插件。在子Xcode中，打开任何工程。确保已经激活通知——在Xcode设置里，激活他们，无论是编译成功和失败。再一次，确保你在更改的是子Xcode的设置。<br><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/05/rayroll-bezel.png" alt=""></p>
<p>使用被创建的<strong>Reset Logger</strong>菜单项重置<strong>notificationSet</strong>，并运行子Xcode工程。</p>
<p>在子Xcode编译成功（或者失败）是，注意控制台里的信息。略读控制台信息，看看是否相关的内容。你是否能进一步瞧出值得查看的通知项？以下的方案可能会给你一点帮助。</p>
<blockquote>
<p>内附方案:通过通知捕捉<br>有几项值得我们进一步观察：</p>
<blockquote>
<ul>
<li>NSWindowWillOrderOffScreenNotification,DVTBezelAlertPanel</li>
<li>NSWindowDidOrderOffScreenNotification,DVTBezelAlertPanel</li>
<li>NSWindowDidOrderOffScreenAndFinishAnimatingNotification,DVTBezelAlertPanel<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/02/XcodeNotificationListeningSourceKitCrash.png" alt=""></li>
</ul>
</blockquote>
</blockquote>
<p>你可以从中选出一条，并且进一步探索它，看看能挖出什么信息。<br>那么<strong>NSWindowWillOrderOffScreenNotification</strong>怎么样？好主意！探索一下它。<br>仍旧是<strong>Rayrolled.m</strong>，找到<strong>handleNotification:</strong>，并且在第一行增加断点，如图所示，之后的几步如下：<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/04/Xcode_Add_Symbolic_Breakpoint.png" alt=""></p>
<ol>
<li>在断点处，右击断点，选择<strong>Edit Breakpoint</strong>；</li>
<li>在条件区域，粘贴<strong>[notification.name isEqualToString:@”NSWindowWillOrderOffScreenNotification”]</strong>；</li>
<li>在<strong>Action</strong>区域，增加<strong>po notification.object</strong>；</li>
<li>如果父Xcode没有在运行子Xcode，那么启动编译器，然后在子Xcode中开始编译。断点就会在<strong>NSWindowWillOrderOffScreenNotification</strong>通知处起作用。观察<strong>-[notification object]</strong>的打印输出。这是<strong>DVTBezelAlertPanel</strong>，是你将要探索的诸多私有类中的第一个。</li>
</ol>
<p>现在开了一好头，你知道一个名为<strong>DVTBezelAlertPanel</strong>的类，并且更重要的是，你有这个类在内存中的实体。而不幸的是，你没有它的头文件，来确定这个实体是否负责显示Xcode的提示。</p>
<p>事实上，获得这个信息是可能的。尽管你没有这个类的头文件，但你的确连接到子Xcode的调试器，并且头文件能告诉你的，内存同样也可以告诉你。</p>
<blockquote>
<p><strong>注意：</strong>对于这套教程，LLDB控制台的输出经常会包括控制台输入。以<strong>(lldb)</strong>开头的行可认为是控制台输入，并且也可以输入。三点…符号输出已从控制台的标准输出里忽略掉了。如果控制台中的巨量信息让你招架不住，按<strong>⌘ + K</strong>可以移除当前的内容，可回归到开始的清爽界面。</p>
</blockquote>
<p>当父Xcode调试器在断点处停止时，在它的LLDB控制台输入以下命令：</p>
<blockquote>
<p>(lldb) image lookup -rn DVTBezelAlertPanel<br>17 matches found in /Application/Xcode.app/Contents/SharedFrameworks/DVTKit.framework/Versions/A/DVTKit:…</p>
</blockquote>
<p>在Xcode内对<strong>DVTBezelAlertPanel</strong>的搜索，同样会在Xcode进程载入的框架、库和插件里搜索，并且会输出匹配的内容。看一下函数列表。在<strong>DVTBezelAlertPanel</strong>图片转储过程中是否有函数将这个类和错误信息联系起来？下面的帮助可供参考。</p>
<blockquote>
<p>解决方案：相关函数<br><strong>DVTBezelAlertPanel</strong>相关函数看起来可以做进一步研究：</p>
<blockquote>
<ul>
<li><strong>initWithIcon:message:parentWindow:duration</strong></li>
<li><strong>initWithIcon:message:controlView:duration:</strong></li>
<li><strong>controlView</strong><br>也许跳出上面两个初始化函数中的一个可以验证你是否跟踪到正确的提示框信息相关的类。</li>
</ul>
</blockquote>
<p><strong>注意：</strong>要知道<strong>image lookup</strong>的LLDB命令将列出内存中被执行的方法。当将此操作应用到一个特别的类上时，会忽略掉该类从其父类继承的方法。也就是说，该命令的搜索将忽略掉任何只在父类声明的方法，这些方法也不包括子类重载其父类的方法。</p>
</blockquote>
<p>LLDB控制台无输出时，以如下命令查看<strong>contentView</strong>属性：</p>
<blockquote>
<p>(lldb) po [notification.object controlView]</p>
<p>&lt;nil&gt; </p>
</blockquote>
<p>控制台返回<strong>nil</strong>。讨厌。也许是因为<strong>controlView</strong>此时没有被赋值。是时候采取不同的策略了。<br><strong>initWithIcon:message:parentWindow:duration</strong>和<strong>initWithIcon:message:controlView:duration:</strong>看似有点<del>多汁</del>。因为你知道<strong>DVTBezelAlertPanel</strong>实体目前还在，所以一定是这两个傻呆呆的方法中的一个执行过。你需要通过LLDB控制台在这两个函数处设个断点，然后再次出发这个类的初始化。</p>
<p>在程序暂停时，在LLDB控制台中输入以下命令：</p>
<blockquote>
<p>(lldb) rb ‘DVTBezelAlertPanel\ initWithIcon:message:’<br>Breakpoint 1: 2 locations.<br>(lldb) br l<br>…</p>
</blockquote>
<p>这是一个正则表达式，它可以在上面的两句<strong>DVTBezelAlertPanel</strong>初始化处均设置上断点。因为两个初始化方法文字有相同的部分，这个表达式对他们都能匹配。确保在空格前有个“\”，并且命令被单引号包括，这样LLDB才知道如何正确的解析此表达式。</p>
<p>恢复子程序的运行，然后重新编译子工程。编译器的断点将在<strong>initWithIcon:message:parentWindow:duration</strong>处停止。<br>如果没有停住，确保父Xcode增加了断点，且子Xcode执行了工程。由于断点处的方法没有对应的源码文件，所以Xcode会在该函数的汇编码中暂停。</p>
<p>由于你找到的函数没有源码文件，那么你需要开动脑筋想办法打印出传入该方法的参数。所以，我们是时候讨论一下<strong>汇编</strong>了！<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/03/AssemblyRage.png" alt=""></p>
<h2 id="了解汇编的快速捷径">了解汇编的快速捷径</h2><p>在运行私有API时，你需要观察<strong>寄存器</strong>，而不是像在调试源代码时所用的调试标识符。知道寄存器在<strong>x86-64</strong>架构上的使用机制是有着巨大帮助的。</p>
<p>尽管这不是必读内容，<a href="https://mikeash.com/pyblog/friday-qa-2011-12-16-disassembling-the-assembly-part-1.html" target="_blank" rel="external">这篇文章</a>是一篇补充x86 Mach-0平台汇编的优秀资源。在我们这套教程的第3部分，将会通过反汇编剖析一个方法，来看看正在执行什么，但不是现在，你将走一条更好走的路。</p>
<p>需要标明一下各个寄存器是什么和是做什么的：</p>
<ul>
<li><p><strong>$rdi:</strong>该寄存器引用了传入函数的<strong>self</strong>参数，是第一个被传入的参数。</p>
</li>
<li><p><strong>$rsi:</strong>引用的<strong>Selector</strong>参数，这是第二个参数。</p>
</li>
<li><p><strong>$rdx:</strong>传入函数的第三个参数，和Objective-C函数的第一个参数。</p>
</li>
<li><p><strong>$rcx:</strong>传入函数的第四个参数，和Objective-C函数的第二个参数。</p>
</li>
<li><p><strong>$r8:</strong>传入函数的第五个参数。如果函数还有参数，<strong>$r9</strong>是参数栈结构里的第六个参数。</p>
</li>
<li><p><strong>$rax:</strong>返回值被存入该寄存器。例如，当跳出<strong>-[aClass description]</strong>，在<strong>$rax</strong>里会有一个<strong>NSString</strong>类型的关于<strong>aClass</strong>实体的描述。</p>
</li>
</ul>
<blockquote>
<p><strong>注意：</strong>上面的讲述在一些情况下是不对的。有时二进制会针对不同的函数参数类型使用不同的寄存器，比如<strong>doubles</strong>则使用<strong>$xmm</strong>寄存器。所以，以上仅可作为参考。</p>
</blockquote>
<p>将这些理论实践一下，看看下面这个函数。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">aClass</span> : <span class="title">NSObject</span></span></span><br><span class="line">-(<span class="built_in">NSString</span> *)aMethodWithMessage:(<span class="built_in">NSString</span> *)message；</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">aClass</span></span></span><br><span class="line">-(<span class="built_in">NSString</span> *)aMethodWithMessage:(<span class="built_in">NSString</span> *)message &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Hey the message is: %@"</span>,message]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>这样调用：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">aClass</span> *<span class="atom">aClassInstance</span> = [[<span class="atom">aClass</span> <span class="atom">alloc</span>] <span class="atom">init</span>];</span><br><span class="line">[<span class="atom">aClassInstance</span> <span class="atom">aMethodWithMessage</span>:@<span class="string">"Hello World"</span>];</span><br></pre></td></tr></table></figure>
<p>编译时，<strong>aMethodWithMessage:</strong>会被传入<strong>objc_msgSend</strong>，看起来大概像这样：</p>
<figure class="highlight"><figcaption><span>@selector(aMethodWithMessage:), @"Hello World")```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;**aClass**&#23454;&#20307;&#30340;**aMethodWithMessage:**&#20989;&#25968;&#20250;&#23558;&#22914;&#19979;&#32467;&#26524;&#20889;&#20837;&#36825;&#19968;&#31995;&#21015;&#30340;&#23492;&#23384;&#22120;&#10;**&#19968;&#26086;&#35843;&#29992;aMethodWithMessage:**&#10;* **$rdi:**&#23384;&#20648;&#19968;&#20010;**aClass**&#23454;&#20307;&#12290;&#10;* **$rsi:**&#23384;&#20648;&#20102;&#36873;&#25321;&#22120;**aMethodWithMessage**&#65292;&#23427;&#20854;&#23454;&#26159;&#20010;**char ***&#65288;&#22312;lldb&#20013;&#35797;&#19968;&#19979;**po (SEL)$rsi**&#65289;&#10;* **$rdx:**&#23384;&#20648;&#20102;**message**&#20869;&#23481;&#65292;&#23427;&#24341;&#29992;&#20102;**@&#34;Hello World&#34;&#30340;&#23454;&#20307;&#12290;&#10;**&#31163;&#24320;&#20989;&#25968;&#26102;**&#10;* **$rax:**&#23384;&#20648;&#36820;&#22238;&#20540;&#65292;&#23427;&#26159;&#19968;&#20010;**NSString**&#23454;&#20307;&#12290;&#22312;&#36825;&#20010;&#20363;&#23376;&#20013;&#65292;&#23427;&#26159;@&#34;Hey the message is:Hello World&#34;&#30340;&#23454;&#20307;&#12290;&#10;&#62; &#35793;&#32773;&#27880;&#65306;&#26412;&#25991;&#20027;&#26696;&#20363;&#26368;&#26032;&#26029;&#28857;&#22788;&#22914;&#26524;&#36755;&#20837;&#10;&#62; po $rcx&#10;&#62; &#23558;&#20250;&#30475;&#21040; Build Succeeded&#10;&#10;## &#28145;&#20837;x86&#23492;&#23384;&#22120;&#26242;&#20648;&#26426;&#21046;&#10;&#10;&#26082;&#28982;&#20320;&#24050;&#26159;&#19968;&#21517;&#19987;&#19994;&#30340;&#27719;&#32534;&#23492;&#23384;&#22120;&#21521;&#23548;&#65292;&#37027;&#20040;&#29616;&#22312;&#37325;&#26032;&#35775;&#38382;**DVTBezelAlertPanel**&#30340;**initWithIcon:message:parentWindow:duration:**&#12290;&#24076;&#26395;&#20320;&#36824;&#27809;&#20174;&#36825;&#20010;&#20989;&#25968;&#30340;&#26029;&#28857;&#19978;&#31227;&#24320;&#12290;&#22914;&#26524;&#20320;&#36825;&#20040;&#20570;&#20102;&#65292;&#37027;&#20040;&#37325;&#26032;&#36816;&#34892;&#23376;Xcode&#12290;&#20877;&#27425;&#25552;&#37266;&#65292;&#20320;&#27491;&#22312;&#23547;&#25214;&#19968;&#20010;&#31867;&#30340;&#32447;&#32034;&#65292;&#23427;&#36127;&#36131;&#20026;&#26174;&#31034;Xcode&#32534;&#35793;&#25104;&#21151;&#25552;&#31034;&#12290;&#10;&#10;&#22312;&#26029;&#28857;**initWithIcon:message:parentWindow:duration**&#22788;&#20572;&#27490;&#21518;&#65292;&#22312;LLDB&#36755;&#20837;&#22914;&#19979;&#65306;&#10;&#10;```(lldb) re re</span><br></pre></td></tr></table></figure>
<p>这条命令是<strong>读寄存器(register read)</strong>的缩写，将打印出机器中一些可用的很重要的寄存器。</p>
<p>用你已经学到的读0x86_64寄存器知识，检查参数<strong>message:</strong>所属的寄存器，和第四个objc_msgSend参数。内容是否与提示字符串相符？</p>
<blockquote>
<p>方法如下：</p>
<p>是的，查看<strong>$rcx</strong>寄存器，可以看到与编译提示对应的<strong>message</strong>参数。</p>
<p>在<strong>LLDB控制台</strong>输入如下，进一步探索：</p>
<blockquote>
<p>(lldb) po $rcx</p>
<p>Build Failed</p>
<blockquote>
<p><strong>注意：</strong>Xcode会打印出<strong>AT&amp;T</strong>风格的汇编。充分了解当前的风格，因为源操作对象和目的操作对象会被交换。</p>
</blockquote>
</blockquote>
<p>看，这就是“元凶”。</p>
</blockquote>
<p>给参数<strong>$rcx</strong>寄存器写入一个新字符串，看看提示框是否改变就可以100%确定了：</p>
<blockquote>
<p>(lldb) po [$rcx class]</p>
<p>__NSCFConstantString               </p>
<p>(lldb) po id $a = @”Womp womp!”;</p>
<p>(lldb) p/x $a</p>
<p>(id) $a = 0x000061800203faa0</p>
<p>(lldb) re w $rcx 0x000061800203faa0</p>
<p>(lldb) c</p>
</blockquote>
<p>﻿</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/04/Womp_Womp_Xcode.png" alt=""></p>
<p>程序恢复运行，注意调试器的提示信息已经改变。现在你可以安全的推断出这个类与编译提示相关联了。已经初露端倪，对不对？</p>
<h2 id="代码注入">代码注入</h2><p>你已经找到了相关的类。现在可以在编译提示显示时，通过代码注入将参数<strong>DVTBezelAlertPanel</strong>的提示图片替换为一张Rayrolling的萌照。</p>
<p>那么<a href="http://nshipster.com/method-swizzling/" target="_blank" rel="external">method swizzling</a>该上场了！</p>
<p>因为你可能要swizzle不同类的数个函数，所以最好用<strong>NSObject</strong>的<strong>Category</strong>创建一个方法以方便进行逻辑构建。</p>
<p>选择<strong>File\New\File…</strong>，并选择<strong>OS X\Source\Objective-C File</strong>模板。命名为<strong>MethodSwizzler</strong>并设置文件类型为<strong>Category</strong>和类NSObject。<br>打开<strong>NSObject+MethodSwizzler.m</strong>，并将其内容替换为如下代码:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"NSObject+MethodSwizzler.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">MethodSwizzler</span>)</span></span><br><span class="line"> </span><br><span class="line">+ (<span class="keyword">void</span>)swizzleWithOriginalSelector:(SEL)originalSelector swizzledSelector:(SEL) swizzledSelector isClassMethod:(<span class="built_in">BOOL</span>)isClassMethod </span><br><span class="line">&#123;</span><br><span class="line">  Class cls = [<span class="keyword">self</span> class];</span><br><span class="line"> </span><br><span class="line">  Method originalMethod;</span><br><span class="line">  Method swizzledMethod;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">if</span> (isClassMethod) &#123;</span><br><span class="line">    originalMethod = class_getClassMethod(cls, originalSelector);</span><br><span class="line">    swizzledMethod = class_getClassMethod(cls, swizzledSelector);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    originalMethod = class_getInstanceMethod(cls, originalSelector);</span><br><span class="line">    swizzledMethod = class_getInstanceMethod(cls, swizzledSelector);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  <span class="keyword">if</span> (!originalMethod) &#123; </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Error: originalMethod is nil, did you spell it incorrectly? %@"</span>, originalMethod);</span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 4</span></span><br><span class="line">  method_exchangeImplementations(originalMethod, swizzledMethod); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>带编号的注释含义依次为：</p>
<ol>
<li>这个神奇的头文件是负责声明用于method swizzling的函数。</li>
<li><strong>isClassMethod</strong>用以判断这些方法是类方法，还是实例方法。</li>
<li>当你不需要编译器帮忙自动编译方法时，很容易拼错方法名。这一步是检查以确保所声明的SEL准确无误。</li>
<li>这个函数会切换到你的实现部分。</li>
</ol>
<p>在<strong>NSObject+MethodSwizzler.h</strong>中声明<strong>swizzleWithOriginalSelector:swizzledSelector:isClassMethod</strong>方式如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line"> </span><br><span class="line"><span class="annotation">@interface</span> NSObject (MethodSwizzler)</span><br><span class="line">+ (<span class="typename">void</span>)<span class="string">swizzleWithOriginalSelector:</span>(SEL)originalSelector <span class="string">swizzledSelector:</span>(SEL) swizzledSelector <span class="string">isClassMethod:</span>(BOOL)isClassMethod;</span><br><span class="line"> </span><br><span class="line"><span class="annotation">@end</span></span><br></pre></td></tr></table></figure>
<p>现在就可以真的swizzle了！创建另一个<strong>Category</strong>并命名为<strong>Rayrolling_DVTBezelAlertPanel</strong>，它继承自<strong>NSObject</strong>。</p>
<p>以如下代码替换<strong>NSObject+Rayrolling_DVTBezelAlertPanel.m</strong>里的内容：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> <span class="string">"NSObject+Rayrolling_DVTBezelAlertPanel.h"</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">#<span class="keyword">import</span> <span class="string">"NSObject+MethodSwizzler.h"</span></span><br><span class="line">#<span class="keyword">import</span> &lt;Cocoa/Cocoa.h&gt;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="annotation">@interface</span> NSObject ()</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">- (id)<span class="string">initWithIcon:</span>(id)arg1 <span class="string">message:</span>(id)arg2 <span class="string">parentWindow:</span>(id)arg3 <span class="string">duration:</span>(<span class="typename">double</span>)arg4;</span><br><span class="line"><span class="annotation">@end</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="annotation">@implementation</span> NSObject (Rayrolling_DVTBezelAlertPanel)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line">+ (<span class="typename">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static</span> dispatch_once_t onceToken;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 6</span></span><br><span class="line">  dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 7</span></span><br><span class="line">    [NSClassFromString(@<span class="string">"DVTBezelAlertPanel"</span>) <span class="string">swizzleWithOriginalSelector:</span><span class="annotation">@selector</span>(<span class="string">initWithIcon:</span><span class="string">message:</span><span class="string">parentWindow:</span><span class="string">duration:</span>) <span class="string">swizzledSelector:</span><span class="annotation">@selector</span>(<span class="string">Rayrolling_initWithIcon:</span><span class="string">message:</span><span class="string">parentWindow:</span><span class="string">duration:</span>) <span class="string">isClassMethod:</span>NO];</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line">- (id)<span class="string">Rayrolling_initWithIcon:</span>(id)icon <span class="string">message:</span>(id)message <span class="string">parentWindow:</span>(id)window <span class="string">duration:</span>(<span class="typename">double</span>)duration</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 9</span></span><br><span class="line">  NSLog(@<span class="string">"Swizzle success! %@"</span>, self);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 10</span></span><br><span class="line">  <span class="keyword">return</span> [self <span class="string">Rayrolling_initWithIcon:</span>icon <span class="string">message:</span>message <span class="string">parentWindow:</span>window <span class="string">duration:</span>duration];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="annotation">@end</span></span><br></pre></td></tr></table></figure>
<p>代码相对的简单明了，解释如下：</p>
<ol>
<li>确保导入要swizzling的方法。</li>
<li>你可以在此声明所有要用到的函数。尽管这不是必要的，但这可以让编译器更好的自动编译你的代码。另外，这个技巧可抑制未声明函数的警告。</li>
<li>这就是你将要swizzling的私有方法。</li>
<li>因为你不想重新声明一个私有类，你可以用分类(category)代替。</li>
<li>这是代码注入“伎俩”的核心。你将在<strong>load</strong>执行注入。<strong>load</strong>函数是唯一的，它里面有<del>一对多的关系</del>。也就是说，同一个类的多个分组都可在一个<strong>load</strong>命令里实现，并执行他们。</li>
<li>由于<strong>load</strong>会被调用多次，所以需要使用<strong>dispatch_once</strong>。</li>
<li>此处使用的是你之前实现过的<strong>NSObject</strong>分类方法。注意，你使用的是<strong>NSClassFromString</strong>来动态检索运行时的私有类。</li>
<li>此处是替代原来的函数。使用一个只有你自己可以规定的唯一命名空间约定，这是一个很好的做法。</li>
<li>此处是测试swizzling能否成功，将字符打印到控制台。</li>
<li>由于你正在swizzle原来的函数，所以当你调用被swizzle的函数时，仍然会调用原来的。这就意味着你可以在原来的方法被调用前后添加一些代码，甚至更改传入的参数…这个一会儿将要用到。</li>
</ol>
<p>恭喜你！你已经成功的将代码注入到一个私有类的私有方法！编译父Xcode，然后编译子Xcode，看看添加控制台的信息是否被swizzle进去了。</p>
<p>现在可以使用Rayrolling的照片替换掉所有编译提示图片了。从<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2015/04/IDEAlertBezel_Generic_Rayrolling.pdf" target="_blank" rel="external">这里</a>下载要swizzle的<a href="http://www.raywenderlich.com/about#cbelanger" target="_blank" rel="external">Crispy</a>的玉照，并将它写入Xcode工程。确保选择上<strong>Copy Items if Needed</strong>。</p>
<p>回到<strong>Rayrolliing_initWithIcon:message:parentWindow:duration</strong>并将其内容更改如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (id)<span class="string">Rayrolling_initWithIcon:</span>(id)arg1 <span class="string">message:</span>(id)arg2 <span class="string">parentWindow:</span>(id)arg3 <span class="string">duration:</span>(<span class="typename">double</span>)arg4 </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (arg1) &#123;  </span><br><span class="line">    NSBundle *bundle = [NSBundle <span class="string">bundleWithIdentifier:</span>@<span class="string">"com.raywenderlich.Rayrolling"</span>];</span><br><span class="line">    NSImage *newImage = [bundle <span class="string">imageForResource:</span>@<span class="string">"IDEAlertBezel_Generic_Rayrolling.pdf"</span>];</span><br><span class="line">    <span class="keyword">return</span> [self <span class="string">Rayrolling_initWithIcon:</span>newImage <span class="string">message:</span>arg2 <span class="string">parentWindow:</span>arg3 <span class="string">duration:</span>arg4];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [self <span class="string">Rayrolling_initWithIcon:</span>arg1 <span class="string">message:</span>arg2 <span class="string">parentWindow:</span>arg3 <span class="string">duration:</span>arg4];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数检查图片是否被传入原来的函数，并将其替换为Rayrolling的图片。需要注意的是你必须要用<strong>+[NSBundle bundleWithIdentifier:]载入图片，因为它并没存储在你的</strong>mainBundle**。<br>编译并运行工程，退出所有的Xcode实体，重启。<br>完美！:]</p>
<h2 id="切换和持久化“雷摇摆”（Rayroll）">切换和持久化“雷摇摆”（Rayroll）</h2><p>你正设计的这个插件也许会惹人烦，很可能你更想让其可以在打开或者关闭状态之间切换，而可以使用<strong>NSUserDefaults</strong>来持久化Xcode的各种实体状态。</p>
<p>回到**Rayrolling.h””，并将如下属性添加到这个头文件：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="list">(<span class="keyword">BOOL</span>)</span>isEnabled<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>到<strong>Rayrolling.m</strong>，并添加如下函数：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)isEnabled &#123;</span><br><span class="line">  <span class="keyword">return</span> [[NSUserDefaults standardUserDefaults] <span class="string">boolForKey:</span>@<span class="string">"com.raywenderlich.Rayrolling.shouldbeEnable"</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">+ (<span class="typename">void</span>)<span class="string">setIsEnabled:</span>(BOOL)shouldBeEnabled &#123;</span><br><span class="line">  [[NSUserDefaults standardUserDefaults] <span class="string">setBool:</span>shouldBeEnabled <span class="string">forKey:</span>@<span class="string">"com.raywenderlich.Rayrolling.shouldbeEnable"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你已经有了持久化你的选择的相关逻辑，现在需要在界面上添加个切换开关。<br>回到<strong>Rayrolling.m</strong>，编辑<em>-(void) doMenuAction*</em>，代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="typename">void</span>)<span class="string">doMenuAction:</span>(NSMenuItem *)menuItem &#123;</span><br><span class="line">  [Rayrolling <span class="string">setIsEnabled:</span>![Rayrolling isEnabled]];</span><br><span class="line">  menuItem.title = [Rayrolling isEnabled] ? @"Disable Rayrolling" : @<span class="string">"Enable Rayrolling"</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这简单实现了切换激活和禁止”Rayrolling”的功能。<br>最后，在<strong>didApplicationFinishLaunchingNotification:</strong>里菜单设置代码，如下：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="name">NSMenuItem</span> *<span class="atom">menuItem</span> = [[<span class="name">NSApp</span> <span class="atom">mainMenu</span>] <span class="atom">itemWithTitle</span>:@<span class="string">"Edit"</span>];</span><br><span class="line"><span class="atom">if</span> (<span class="atom">menuItem</span>) &#123;</span><br><span class="line">  [[<span class="atom">menuItem</span> <span class="atom">submenu</span>] <span class="atom">addItem</span>:[<span class="name">NSMenuItem</span> <span class="atom">separatorItem</span>]];</span><br><span class="line">  <span class="name">NSString</span> *<span class="atom">title</span> = [<span class="name">Rayrolling</span> <span class="atom">isEnabled</span>] ? @<span class="string">"Disable Rayrolling"</span> : @<span class="string">"Enable Rayrolling"</span>;</span><br><span class="line">  <span class="name">NSMenuItem</span> *<span class="atom">actionMenuItem</span> = [[<span class="name">NSMenuItem</span> <span class="atom">alloc</span>] <span class="atom">initWithTitle</span>:<span class="atom">title</span> <span class="atom">action</span>:@<span class="atom">selector</span>(<span class="atom">doMenuAction</span>:) <span class="atom">keyEquivalent</span>:@<span class="string">""</span>];</span><br><span class="line">  [<span class="atom">actionMenuItem</span> <span class="atom">setTarget</span>:<span class="atom">self</span>];</span><br><span class="line">  [[<span class="atom">menuItem</span> <span class="atom">submenu</span>] <span class="atom">addItem</span>:<span class="atom">actionMenuItem</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在你有个菜单项，它会持久化Xcode启动状态，并记住打开或关闭此逻辑的设定。<br>回到<strong>NSObject+Rayrolling_DVTBezelAlertPanel.m</strong>，并添加如下引用：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#import</span> <span class="string">"Rayrolling.h"</span></span><br></pre></td></tr></table></figure>
<p>最后，打开<strong>Rayrolling_initWithIcon:message:parentWindow:duration:</strong>，并将</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(arg1)</span> &#123;</span><br></pre></td></tr></table></figure>
<p>替换为</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">([Rayrolling isEnabled] &amp;&amp; arg1)</span> &#123;</span><br></pre></td></tr></table></figure>
<p>编译并运行程序，这个变化对你的插件会有一定的宣传作用。<br>Boom!你现在已经拥有可以编辑Xcode提示，并可以打开和关掉的插件。今天完美收工，是不是？</p>
<h2 id="接下来，做什么？">接下来，做什么？</h2><p>你可以从这里下载本教程的<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2015/05/Rayrolling_Part1_Final.zip" target="_blank" rel="external">完整Rayrolling工程</a>。</p>
<p>虽然你已经有了不少的进展，但是仍然有很多东西要做？在第2部分，你将学习动态跟踪（Dtrace）和探索一些LLDB的高阶特性的基础，可以深入的观察到Xcode正运行的进程。</p>
<p>如果你想预习一些知识，在第3部分前有一些作业，里面有不少汇编代码。现在可通过阅读Mike Ash的关于反汇编的<a href="https://www.mikeash.com/pyblog/friday-qa-2011-12-16-disassembling-the-assembly-part-1.html" target="_blank" rel="external">第1部分</a>和<a href="https://www.mikeash.com/pyblog/friday-qa-2011-12-23-disassembling-the-assembly-part-2.html" target="_blank" rel="external">第2部分</a>文章，来学习和补充一些X86_64的汇编知识。这两篇文章对理解接下来的内容很有帮助。</p>
<p>好运吧，祝愉快！如果你关于本教程有任何的意见和问题，请在<a href="http://www.raywenderlich.com/94020/creating-an-xcode-plugin-part-1" target="_blank" rel="external">下面</a>留言。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/02/13/如何制作Xcode插件：1-3-1/" data-id="cikkpj8h90002kn05izf5tb2i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-如何制作Xcode插件：1-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/12/如何制作Xcode插件：1-3/" class="article-date">
  <time datetime="2016-02-12T12:11:05.000Z" itemprop="datePublished">2016-02-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="如何制作Xcode插件：1/3">如何制作Xcode插件：1/3</h1><p>译者注：在学习写xcode插件的过程中，找了一些资料，其中<a href="www.raywenderlich.com">www.raywenderlich.com</a>中的三篇文章写得很好，这是其中的第一篇《<a href="http://http://www.raywenderlich.com/94020/creating-an-xcode-plugin-part-1" target="_blank" rel="external">How To Create an Xcode Plugin:Part1/3 </a>》。</p>
<hr>
<p><strong>更新备注：</strong>这篇教程只用Xcode6.3.2测试过——如果你使用的其他版本的Xcode，那么你的经历可能会与这篇教程中的有一定出入。</p>
<p>苹果公司针对扩展其产品的“一刀切”的规则就像让人强吞下一颗难以忍受的药丸。尽管目前苹果公司强制iOS或者OS X平台的开发者使用它的工作流程，但是仍然可以通过制作插件的方式使Xcode更为适用。</p>
<p>这不是关于如何制作Xcode插件的苹果公司官方文档，但是开发社区已经做了数量惊人的工作致力于帮助让开发者拥有更为有效的工具。</p>
<p>从<a href="https://github.com/ksuther/KSImageNamed-Xcode" target="_blank" rel="external">autocompletion for images</a>，到nuking你的<a href="https://github.com/kattrali/deriveddata-exterminator" target="_blank" rel="external">Derived Data</a>，再到<a href="https://github.com/XVimProject/XVim" target="_blank" rel="external">vim editor</a>，Xcode插件社区已经推动了原本被认为可以推动的边界。</p>
<p>在这史诗般的三篇教程中，你将制作一款Xcode插件来恶搞你的搭档，而主演恶搞者的人没有一人比他更爱恶作剧——Ray本人。虽然这些插件看似轻松搞笑，但是你仍然可以从中学习到许多通过Xcode跟踪，如何找到你想要修改的元素，以及如何swizzle进你自己的函数。</p>
<p>你将会查阅一些未公开的框架，会用到如下技术：<a href="https://www.mikeash.com/pyblog/friday-qa-2011-12-16-disassembling-the-assembly-part-1.html" target="_blank" rel="external">X86汇编知识</a>，<a href="http://www.raywenderlich.com/79600/navigating-a-new-codebase" target="_blank" rel="external">源码的导航技巧</a>和在探索私有API和用<a href="http://nshipster.com/method-swizzling/" target="_blank" rel="external">method swizzling</a>做代码注入的<a href="http://www.raywenderlich.com/?s=lldb" target="_blank" rel="external">LLDB技术</a> 。由于会涉及到的方方面面较多，所以这篇教程会进行的较快。那么，在开始之前确保你的iOS或OS X平台在最佳状态吧！</p>
<p>使用Swift进行插件开发会严重复杂化这个原本就已经很棘手的题目，况且Swift调试工具相较于Objectvie-C的仍然有所不足。所以现在，(在这篇教程中)开发插件最好的选择是Objective-C。</p>
<hr>
<h2 id="开始">开始</h2><p>为了庆祝“恶搞搭档日”，你的Xcode插件将“瑞克摇摆”为你的牺牲者。稍等，什么是“瑞克摇摆”？它是免费版本的<a href="https://en.wikipedia.org/wiki/Rickrolling" target="_blank" rel="external">“瑞克摇摆”</a>的版权和版税，就是将牺牲者替换到大家原本预期会出现的内容里。当你完成后，插件将Xcode变成下面的样子：</p>
<ol>
<li><p>将Ray的脸蛋植入到Xcode的通知中（例如：编译成功或失败）。<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/04/Xcode_Swizzle_DispalAlert.png" alt=""></p>
</li>
<li><p>将Ray流行一时的歌曲植入到标题栏内，<strong>永不放弃你</strong>。<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/05/Plugin_Swizzled_Titlebar.png" alt=""></p>
</li>
<li><p>将所有Xcode文档请求都重置到<a href="https://www.youtube.com/watch?v=ce-_0opZzh0" target="_blank" rel="external">“瑞克摇摆”的录像</a><br><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/04/Plugin_Swizzle_Documentation-700x288.png" alt=""></p>
</li>
</ol>
<p>在教程的第一部分，你们将集中精力一路跟踪到负责显示“编译完成”通知的类，并将其修改为Ray的一张大头照。</p>
<h1 id="安装Alcatraz插件">安装Alcatraz插件</h1><p>在做任何事之前，都应该先安装<a href="http://alcatraz.io/" target="_blank" rel="external">Alcatraz</a>。Alcatraz是Xcode插件的管家，它的作者是天才的开发者<a href="https://twitter.com/kattrali" target="_blank" rel="external">@kattrali</a>，<a href="https://twitter.com/_supermarin" target="_blank" rel="external">@_supermarin</a>和<a href="https://twitter.com/JurreTweet" target="_blank" rel="external">@jurreTweet</a>。</p>
<p>安装Alcatraz，在终端上执行如下命令：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL http<span class="variable">s:</span>//raw.github.<span class="keyword">com</span>/supermarin/Alcatraz/master/Scripts/install.<span class="keyword">sh</span> | <span class="keyword">sh</span></span><br></pre></td></tr></table></figure>
<p>脚本执行完成后，重启Xcode。会看到Alcatraz bundle的如下提示框；点击<strong>Load Bundle</strong>。你一定想要更强力的Xcode，对不对？<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/05/Xcode6.3.2.png" alt=""></p>
<blockquote>
<p><strong>注意</strong>：如果你不小心点击了“Skip Bundle”，可以通过在终端里执行如下命令再次开启这个提示框：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="stylus">&gt; defaults delete com<span class="class">.apple</span><span class="class">.dt</span><span class="class">.Xcode</span> DVTPlugInManagerNonApplePlugIns-Xcode-<span class="number">6.3</span>.<span class="number">2</span></span><br><span class="line">&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>在Xcode的<strong>Window</strong>菜单会出现一个名为<strong>Package Manager</strong>的新选项。制作Xcode插件要通过在<strong>Build Settings</strong>做诸多设置，并将Xcode依附到另一个Xcode实体上。幸运的是，<a href="witter.com/kattral">@kattrali</a>已经为你做了这些工作，并可通过模板创建插件。</p>
<p>找到<strong>Window\Package Manager</strong>菜单，打开<strong>Alcatraz</strong>插件。在Alcatraz搜索框中，搜索<strong>Xcode Plugin</strong>。确保搜索窗口的<strong>All</strong>和<strong>Templates</strong>属性被选中。一旦找到Xcode的插件模板，点击它左边的安装按钮：<br><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/05/XcodeAlcatrazPlugin-700x208.png" alt=""></p>
<p>一旦Alcatraz下载插件完成，就可以通过菜单<strong>File\New\Project…</strong>创建新功能，选择新建<strong>OS X\Xcode Plugin\Xcode Plugin</strong>模板选项，并点击<strong>Next</strong>。<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/05/XcodePluginSelection-480x282.png" alt=""><br>产品的名字设为“Rayrolling”，设置组织识别码为<strong>com.raywenderlich</strong>（这很重要），并选择<strong>Objective-C</strong>作为开发语言，保存工程到任何你想要的目录中。<br><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/05/Plugin_Xcode_Setup-480x281.png" alt="">    </p>
<h1 id="Hello_World插件模板">Hello World插件模板</h1><p>编译并运行新的Rayrool工程，你会看到一个新的Xcode<strong>子</strong>实体。这个子实体在<strong>Edit</strong>菜单里会出现名为<strong>Do Action</strong>的新选项：<br><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/02/XcodePluginHelloWorld.png" alt=""></p>
<p>选择该菜单项会启动一个模式对话框：<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/05/Screen-Shot-2015-05-11-at-8.48.27-PM.png" alt=""></p>
<p>插件被标定在特定版本的Xcode中运行，意味着当新版本的Xcode出现，所有的社区制作的第三方插件都会失效，直到添加该版本特定的UUID。如果个别模板无法正常工作，并且也看不到新菜单项，可能添加对该版本Xcode的支持。<br>在<strong>终端</strong>中运行如下命令：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults <span class="keyword">read</span> <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/I</span>nfo DVTPlugInCompatibilityUUID</span><br></pre></td></tr></table></figure>
<p>这条命令会输出你目前所使用的Xcode的UUID。打开插件的<strong>Info.plist</strong>，并找到键名<strong>DVTPlugInCompatibilityUUID</strong>，将值添加到该数组中：<br><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/05/DVTCompatibilityUUIDs.gif" alt=""></p>
<blockquote>
<p><strong>注意：</strong>整片教程中，你将运行和修改已安装的插件。这将会改变Xcode的行为，并且有可能会是Xcode崩溃！如果你想禁用一个插件，你需要手动使用如下命令移除它：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">~/Library/</span>Application\ Support<span class="regexp">/Developer/</span>Shared<span class="regexp">/Xcode/</span>Plug-ins/</span><br><span class="line">rm -r Rayrolling.xcplugin/</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>然后重启Xcode。</p>
<h1 id="查找可修改的特性">查找可修改的特性</h1><p>想获取后台将会发生什么，一个基本的尝试和正确的方式是通过<em>NSNotification observer</em>，它监听着所有Xcode发生的事件。通过使用Xcode和监视这些被触发的通知，你将能够一窥底层的一些东西。</p>
<p>打开<strong>Rayrolling.m</strong>，并将下面的属性添加到这个类中</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableSet</span> *notificationSet;</span><br></pre></td></tr></table></figure>
<p>这个<strong>NSMutableSet</strong>保存了所有Xcode控制台输出的<strong>NSNotification</strong>名称。下一步，在<strong>if (self = [super init]) {</strong>这一行之后，增加<strong>initWithBundle:</strong>的相关代码：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter] <span class="string">addObserver:</span>self <span class="string">selector:</span><span class="annotation">@selector</span>(<span class="string">handleNotification:</span>) <span class="string">name:</span>nil <span class="string">object:</span>nil];</span><br><span class="line"></span><br><span class="line">self.notificationSet = [NSMutableSet <span class="keyword">new</span>];</span><br></pre></td></tr></table></figure>
<p>参数<strong>name</strong>传nil，表明你想要监听Xcode分发的所有通知。<br>现在来实现<strong>handleNotification:</strong>，如下所示：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)handleNotification:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">  <span class="keyword">if</span> (![<span class="keyword">self</span><span class="variable">.notificationSet</span> containsObject:notification<span class="variable">.name</span>]) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@, %@"</span>, notification<span class="variable">.name</span>, [notification<span class="variable">.object</span> class]);</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.notificationSet</span> addObject:notification<span class="variable">.name</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>handleNotification:</strong>检查这个通知的名字是否在<strong>notificationSet</strong>中；如果不在，打印出通知的<strong>名字</strong>和<strong>类</strong>，并将之添加到该集合之中。这样，每种被报告的通知你只会看到一次。<br>接下来，查找并替换声明的新增行为菜单项，并更新其标题文字：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSMenuItem *actionMenuItem = [[NSMenuItem alloc] <span class="string">initWithTitle:</span>@<span class="string">"Reset Logger"</span></span><br><span class="line"><span class="label"> action:</span><span class="annotation">@selector</span>(doMenuAction) <span class="string">keyEquivalent:</span>@<span class="string">""</span>];</span><br></pre></td></tr></table></figure>
<p>对<strong>NSMenuItem</strong>标题的这次微小的修改，仅是让你了解点击菜单的动作会重置<strong>NSNotificationset</strong>。<br>最后，替换<strong>doMenuAction</strong>的实现，代码如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (void)<span class="tag">doMenuAction</span> &#123;</span><br><span class="line">  <span class="attr_selector">[self.notificationSet removeAllObjects]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个菜单项现在将重置<strong>notificationSet</strong>属性中的所有通知。这将让你在滤掉“控制台噪音”后，检查你想看的通知项。</p>
<p>再一次编译并运行插件，以重新启动子Xcode。确保你清晰的区分开运行中的<strong>父Xcode</strong>和正在调试状态的<strong>子Xcode</strong>实例，因为父不会包含最新的插件更改，直到你重新启动Xcode将之载入内存。<br>随便操作一下子Xcode：点击按钮，打开窗口，并浏览一下应用，在父Xcode控制台会监视到所有的这些通知。</p>
<h1 id="查找并观察编译状态提示">查找并观察编译状态提示</h1><p>既然你已经可以观察Xcode中被触发的<strong>NSNotification</strong>名称，你只需将注意与显示编译提示相关联的类上。</p>
<p>启动Xcode插件。在子Xcode中，打开任何工程。确保已经<del>激活通知</del>——在Xcode设置里，激活他们，无论是编译成功和失败。再一次，确保你在更改的是子Xcode的设置。<br><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/05/rayroll-bezel.png" alt=""></p>
<p>使用被创建的<strong>Reset Logger</strong>菜单项重置<strong>notificationSet</strong>，并运行子Xcode工程。</p>
<p>在子Xcode编译成功（或者失败）是，注意控制台里的信息。略读控制台信息，看看是否相关的内容。你是否能进一步瞧出值得查看的通知项？以下的方案可能会给你一点帮助。</p>
<blockquote>
<p>内附方案:通过通知捕捉<br>有几项值得我们进一步观察：</p>
<blockquote>
<ul>
<li>NSWindowWillOrderOffScreenNotification,DVTBezelAlertPanel</li>
<li>NSWindowDidOrderOffScreenNotification,DVTBezelAlertPanel</li>
<li>NSWindowDidOrderOffScreenAndFinishAnimatingNotification,DVTBezelAlertPanel<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/02/XcodeNotificationListeningSourceKitCrash.png" alt=""></li>
</ul>
</blockquote>
</blockquote>
<p>你可以从中选出一条，并且进一步探索它，看看能挖出什么信息。<br>那么<strong>NSWindowWillOrderOffScreenNotification</strong>怎么样？好主意！探索一下它。<br>仍旧是<strong>Rayrolled.m</strong>，找到<strong>handleNotification:</strong>，并且在第一行增加断点，如图所示，之后的几步如下：<br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/04/Xcode_Add_Symbolic_Breakpoint.png" alt=""></p>
<ol>
<li>在断点处，右击断点，选择<strong>Edit Breakpoint</strong>；</li>
<li>在条件区域，粘贴<strong>[notification.name isEqualToString:@”NSWindowWillOrderOffScreenNotification”]</strong>；</li>
<li>在<strong>Action</strong>区域，增加<strong>po notification.object</strong>；</li>
<li>如果父Xcode没有在运行子Xcode，那么启动编译器，然后在子Xcode中开始编译。断点就会在<strong>NSWindowWillOrderOffScreenNotification</strong>通知处起作用。观察<strong>-[notification object]</strong>的打印输出。这是<strong>DVTBezelAlertPanel</strong>，是你将要探索的诸多私有类中的第一个。</li>
</ol>
<p>现在开了一好头，你知道一个名为<strong>DVTBezelAlertPanel</strong>的类，并且更重要的是，你有这个类在内存中的实体。而不幸的是，你没有它的头文件，来确定这个实体是否负责显示Xcode的提示。</p>
<p>事实上，获得这个信息是可能的。尽管你没有这个类的头文件，但你的确连接到子Xcode的调试器，并且头文件能告诉你的，内存同样也可以告诉你。</p>
<blockquote>
<p><strong>注意：</strong>对于这套教程，LLDB控制台的输出经常会包括控制台输入。以<strong>(lldb)</strong>开头的行可认为是控制台输入，并且也可以输入。三点…符号输出已从控制台的标准输出里忽略掉了。如果控制台中的巨量信息让你招架不住，按<strong>⌘ + K</strong>可以移除当前的内容，可回归到开始的清爽界面。</p>
</blockquote>
<p>当父Xcode调试器在断点处停止时，在它的LLDB控制台输入以下命令：</p>
<blockquote>
<p>(lldb) image lookup -rn DVTBezelAlertPanel<br>17 matches found in /Application/Xcode.app/Contents/SharedFrameworks/DVTKit.framework/Versions/A/DVTKit:…</p>
</blockquote>
<p>在Xcode内对<strong>DVTBezelAlertPanel</strong>的搜索，同样会在Xcode进程载入的框架、库和插件里搜索，并且会输出匹配的内容。看一下函数列表。在<strong>DVTBezelAlertPanel</strong>图片转储过程中是否有函数将这个类和错误信息联系起来？下面的帮助可供参考。</p>
<blockquote>
<p>解决方案：相关函数<br><strong>DVTBezelAlertPanel</strong>相关函数看起来可以做进一步研究：</p>
<blockquote>
<ul>
<li><strong>initWithIcon:message:parentWindow:duration</strong></li>
<li><strong>initWithIcon:message:controlView:duration:</strong></li>
<li><strong>controlView</strong><br>也许跳出上面两个初始化函数中的一个可以验证你是否跟踪到正确的提示框信息相关的类。</li>
</ul>
</blockquote>
<p><strong>注意：</strong>要知道<strong>image lookup</strong>的LLDB命令将列出内存中被执行的方法。当将此操作应用到一个特别的类上时，会忽略掉该类从其父类继承的方法。也就是说，该命令的搜索将忽略掉任何只在父类声明的方法，这些方法也不包括子类重载其父类的方法。</p>
</blockquote>
<p>LLDB控制台无输出时，以如下命令查看<strong>contentView</strong>属性：</p>
<blockquote>
<p>(lldb) po [notification.object controlView]</p>
<p>&lt;nil&gt; </p>
</blockquote>
<p>控制台返回<strong>nil</strong>。讨厌。也许是因为<strong>controlView</strong>此时没有被赋值。是时候采取不同的策略了。<br><strong>initWithIcon:message:parentWindow:duration</strong>和<strong>initWithIcon:message:controlView:duration:</strong>看似有点<del>多汁</del>。因为你知道<strong>DVTBezelAlertPanel</strong>实体目前还在，所以一定是这两个傻呆呆的方法中的一个执行过。你需要通过LLDB控制台在这两个函数处设个断点，然后再次出发这个类的初始化。</p>
<p>在程序暂停时，在LLDB控制台中输入以下命令：</p>
<blockquote>
<p>(lldb) rb ‘DVTBezelAlertPanel\ initWithIcon:message:’<br>Breakpoint 1: 2 locations.<br>(lldb) br l<br>…</p>
</blockquote>
<p>这是一个正则表达式，它可以在上面的两句<strong>DVTBezelAlertPanel</strong>初始化处均设置上断点。因为两个初始化方法文字有相同的部分，这个表达式对他们都能匹配。确保在空格前有个“\”，并且命令被单引号包括，这样LLDB才知道如何正确的解析此表达式。</p>
<p>恢复子程序的运行，然后重新编译子工程。编译器的断点将在<strong>initWithIcon:message:parentWindow:duration</strong>处停止。<br>如果没有停住，确保父Xcode增加了断点，且子Xcode执行了工程。由于断点处的方法没有对应的源码文件，所以Xcode会在该函数的汇编码中暂停。</p>
<p>由于你找到的函数没有源码文件，那么你需要开动脑筋想办法打印出传入该方法的参数。所以，我们是时候讨论一下<strong>汇编</strong>了！<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/03/AssemblyRage.png" alt=""></p>
<h1 id="了解汇编的快速捷径">了解汇编的快速捷径</h1><p>在运行私有API时，你需要观察<strong>寄存器</strong>，而不是像在调试源代码时所用的调试标识符。知道寄存器在<strong>x86-64</strong>架构上的使用机制是有着巨大帮助的。</p>
<p>尽管这不是必读内容，<a href="https://mikeash.com/pyblog/friday-qa-2011-12-16-disassembling-the-assembly-part-1.html" target="_blank" rel="external">这篇文章</a>是一篇补充x86 Mach-0平台汇编的优秀资源。在我们这套教程的第3部分，将会通过反汇编剖析一个方法，来看看正在执行什么，但不是现在，你将走一条更好走的路。</p>
<p>需要标明一下各个寄存器是什么和是做什么的：</p>
<ul>
<li><p><strong>$rdi:</strong>该寄存器引用了传入函数的<strong>self</strong>参数，是第一个被传入的参数。</p>
</li>
<li><p><strong>$rsi:</strong>引用的<strong>Selector</strong>参数，这是第二个参数。</p>
</li>
<li><p><strong>$rdx:</strong>传入函数的第三个参数，和Objective-C函数的第一个参数。</p>
</li>
<li><p><strong>$rcx:</strong>传入函数的第四个参数，和Objective-C函数的第二个参数。</p>
</li>
<li><p><strong>$r8:</strong>传入函数的第五个参数。如果函数还有参数，<strong>$r9</strong>是参数栈结构里的第六个参数。</p>
</li>
<li><p><strong>$rax:</strong>返回值被存入该寄存器。例如，当跳出<strong>-[aClass description]</strong>，在<strong>$rax</strong>里会有一个<strong>NSString</strong>类型的关于<strong>aClass</strong>实体的描述。</p>
</li>
</ul>
<blockquote>
<p><strong>注意：</strong>上面的讲述在一些情况下是不对的。有时二进制会针对不同的函数参数类型使用不同的寄存器，比如<strong>doubles</strong>则使用<strong>$xmm</strong>寄存器。所以，以上仅可作为参考。</p>
</blockquote>
<p>将这些理论实践一下，看看下面这个函数。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">aClass</span> : <span class="title">NSObject</span></span></span><br><span class="line">-(<span class="built_in">NSString</span> *)aMethodWithMessage:(<span class="built_in">NSString</span> *)message；</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">aClass</span></span></span><br><span class="line">-(<span class="built_in">NSString</span> *)aMethodWithMessage:(<span class="built_in">NSString</span> *)message &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Hey the message is: %@"</span>,message]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>这样调用：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">aClass</span> *<span class="atom">aClassInstance</span> = [[<span class="atom">aClass</span> <span class="atom">alloc</span>] <span class="atom">init</span>];</span><br><span class="line">[<span class="atom">aClassInstance</span> <span class="atom">aMethodWithMessage</span>:@<span class="string">"Hello World"</span>];</span><br></pre></td></tr></table></figure>
<p>编译时，<strong>aMethodWithMessage:</strong>会被传入<strong>objc_msgSend</strong>，看起来大概像这样：</p>
<figure class="highlight"><figcaption><span>@selector(aMethodWithMessage:), @"Hello World")```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;**aClass**&#23454;&#20307;&#30340;**aMethodWithMessage:**&#20989;&#25968;&#20250;&#23558;&#22914;&#19979;&#32467;&#26524;&#20889;&#20837;&#36825;&#19968;&#31995;&#21015;&#30340;&#23492;&#23384;&#22120;&#10;**&#19968;&#26086;&#35843;&#29992;aMethodWithMessage:**&#10;* **$rdi:**&#23384;&#20648;&#19968;&#20010;**aClass**&#23454;&#20307;&#12290;&#10;* **$rsi:**&#23384;&#20648;&#20102;&#36873;&#25321;&#22120;**aMethodWithMessage**&#65292;&#23427;&#20854;&#23454;&#26159;&#20010;**char ***&#65288;&#22312;lldb&#20013;&#35797;&#19968;&#19979;**po (SEL)$rsi**&#65289;&#10;* **$rdx:**&#23384;&#20648;&#20102;**message**&#20869;&#23481;&#65292;&#23427;&#24341;&#29992;&#20102;**@&#34;Hello World&#34;&#30340;&#23454;&#20307;&#12290;&#10;**&#31163;&#24320;&#20989;&#25968;&#26102;**&#10;* **$rax:**&#23384;&#20648;&#36820;&#22238;&#20540;&#65292;&#23427;&#26159;&#19968;&#20010;**NSString**&#23454;&#20307;&#12290;&#22312;&#36825;&#20010;&#20363;&#23376;&#20013;&#65292;&#23427;&#26159;@&#34;Hey the message is:Hello World&#34;&#30340;&#23454;&#20307;&#12290;&#10;&#62; &#35793;&#32773;&#27880;&#65306;&#26412;&#25991;&#20027;&#26696;&#20363;&#26368;&#26032;&#26029;&#28857;&#22788;&#22914;&#26524;&#36755;&#20837;&#10;&#62; po $rcx&#10;&#62; &#23558;&#20250;&#30475;&#21040; Build Succeeded&#10;&#10;# &#28145;&#20837;x86&#23492;&#23384;&#22120;&#26242;&#20648;&#26426;&#21046;&#10;&#10;&#26082;&#28982;&#20320;&#24050;&#26159;&#19968;&#21517;&#19987;&#19994;&#30340;&#27719;&#32534;&#23492;&#23384;&#22120;&#21521;&#23548;&#65292;&#37027;&#20040;&#29616;&#22312;&#37325;&#26032;&#35775;&#38382;**DVTBezelAlertPanel**&#30340;**initWithIcon:message:parentWindow:duration:**&#12290;&#24076;&#26395;&#20320;&#36824;&#27809;&#20174;&#36825;&#20010;&#20989;&#25968;&#30340;&#26029;&#28857;&#19978;&#31227;&#24320;&#12290;&#22914;&#26524;&#20320;&#36825;&#20040;&#20570;&#20102;&#65292;&#37027;&#20040;&#37325;&#26032;&#36816;&#34892;&#23376;Xcode&#12290;&#20877;&#27425;&#25552;&#37266;&#65292;&#20320;&#27491;&#22312;&#23547;&#25214;&#19968;&#20010;&#31867;&#30340;&#32447;&#32034;&#65292;&#23427;&#36127;&#36131;&#20026;&#26174;&#31034;Xcode&#32534;&#35793;&#25104;&#21151;&#25552;&#31034;&#12290;&#10;&#10;&#22312;&#26029;&#28857;**initWithIcon:message:parentWindow:duration**&#22788;&#20572;&#27490;&#21518;&#65292;&#22312;LLDB&#36755;&#20837;&#22914;&#19979;&#65306;&#10;&#10;```(lldb) re re</span><br></pre></td></tr></table></figure>
<p>这条命令是<strong>读寄存器(register read)</strong>的缩写，将打印出机器中一些可用的很重要的寄存器。</p>
<p>用你已经学到的读0x86_64寄存器知识，检查参数<strong>message:</strong>所属的寄存器，和第四个objc_msgSend参数。内容是否与提示字符串相符？</p>
<blockquote>
<p>方法如下：</p>
<p>是的，查看<strong>$rcx</strong>寄存器，可以看到与编译提示对应的<strong>message</strong>参数。</p>
<p>在<strong>LLDB控制台</strong>输入如下，进一步探索：</p>
<blockquote>
<p>(lldb) po $rcx</p>
<p>Build Failed</p>
<blockquote>
<p><strong>注意：</strong>Xcode会打印出<strong>AT&amp;T</strong>风格的汇编。充分了解当前的风格，因为源操作对象和目的操作对象会被交换。</p>
</blockquote>
</blockquote>
<p>看，这就是“元凶”。</p>
</blockquote>
<p>给参数<strong>$rcx</strong>寄存器写入一个新字符串，看看提示框是否改变就可以100%确定了：</p>
<blockquote>
<p>(lldb) po [$rcx class]</p>
<p>__NSCFConstantString               </p>
<p>(lldb) po id $a = @”Womp womp!”;</p>
<p>(lldb) p/x $a</p>
<p>(id) $a = 0x000061800203faa0</p>
<p>(lldb) re w $rcx 0x000061800203faa0</p>
<p>(lldb) c</p>
</blockquote>
<p>﻿</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/04/Womp_Womp_Xcode.png" alt=""></p>
<p>程序恢复运行，注意调试器的提示信息已经改变。现在你可以安全的推断出这个类与编译提示相关联了。已经初露端倪，对不对？</p>
<h1 id="代码注入">代码注入</h1><p>你已经找到了相关的类。现在可以在编译提示显示时，通过代码注入将参数<strong>DVTBezelAlertPanel</strong>的提示图片替换为一张Rayrolling的萌照。</p>
<p>那么<a href="http://nshipster.com/method-swizzling/" target="_blank" rel="external">method swizzling</a>该上场了！</p>
<p>因为你可能要swizzle不同类的数个函数，所以最好用<strong>NSObject</strong>的<strong>Category</strong>创建一个方法以方便进行逻辑构建。</p>
<p>选择<strong>File\New\File…</strong>，并选择<strong>OS X\Source\Objective-C File</strong>模板。命名为<strong>MethodSwizzler</strong>并设置文件类型为<strong>Category</strong>和类NSObject。<br>打开<strong>NSObject+MethodSwizzler.m</strong>，并将其内容替换为如下代码:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"NSObject+MethodSwizzler.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">MethodSwizzler</span>)</span></span><br><span class="line"> </span><br><span class="line">+ (<span class="keyword">void</span>)swizzleWithOriginalSelector:(SEL)originalSelector swizzledSelector:(SEL) swizzledSelector isClassMethod:(<span class="built_in">BOOL</span>)isClassMethod </span><br><span class="line">&#123;</span><br><span class="line">  Class cls = [<span class="keyword">self</span> class];</span><br><span class="line"> </span><br><span class="line">  Method originalMethod;</span><br><span class="line">  Method swizzledMethod;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">if</span> (isClassMethod) &#123;</span><br><span class="line">    originalMethod = class_getClassMethod(cls, originalSelector);</span><br><span class="line">    swizzledMethod = class_getClassMethod(cls, swizzledSelector);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    originalMethod = class_getInstanceMethod(cls, originalSelector);</span><br><span class="line">    swizzledMethod = class_getInstanceMethod(cls, swizzledSelector);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  <span class="keyword">if</span> (!originalMethod) &#123; </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Error: originalMethod is nil, did you spell it incorrectly? %@"</span>, originalMethod);</span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 4</span></span><br><span class="line">  method_exchangeImplementations(originalMethod, swizzledMethod); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>带编号的注释含义依次为：</p>
<ol>
<li>这个神奇的头文件是负责声明用于method swizzling的函数。</li>
<li><strong>isClassMethod</strong>用以判断这些方法是类方法，还是实例方法。</li>
<li>当你不需要编译器帮忙自动编译方法时，很容易拼错方法名。这一步是检查以确保所声明的SEL准确无误。</li>
<li>这个函数会切换到你的实现部分。</li>
</ol>
<p>在<strong>NSObject+MethodSwizzler.h</strong>中声明<strong>swizzleWithOriginalSelector:swizzledSelector:isClassMethod</strong>方式如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line"> </span><br><span class="line"><span class="annotation">@interface</span> NSObject (MethodSwizzler)</span><br><span class="line">+ (<span class="typename">void</span>)<span class="string">swizzleWithOriginalSelector:</span>(SEL)originalSelector <span class="string">swizzledSelector:</span>(SEL) swizzledSelector <span class="string">isClassMethod:</span>(BOOL)isClassMethod;</span><br><span class="line"> </span><br><span class="line"><span class="annotation">@end</span></span><br></pre></td></tr></table></figure>
<p>现在就可以真的swizzle了！创建另一个<strong>Category</strong>并命名为<strong>Rayrolling_DVTBezelAlertPanel</strong>，它继承自<strong>NSObject</strong>。</p>
<p>以如下代码替换<strong>NSObject+Rayrolling_DVTBezelAlertPanel.m</strong>里的内容：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> <span class="string">"NSObject+Rayrolling_DVTBezelAlertPanel.h"</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">#<span class="keyword">import</span> <span class="string">"NSObject+MethodSwizzler.h"</span></span><br><span class="line">#<span class="keyword">import</span> &lt;Cocoa/Cocoa.h&gt;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="annotation">@interface</span> NSObject ()</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">- (id)<span class="string">initWithIcon:</span>(id)arg1 <span class="string">message:</span>(id)arg2 <span class="string">parentWindow:</span>(id)arg3 <span class="string">duration:</span>(<span class="typename">double</span>)arg4;</span><br><span class="line"><span class="annotation">@end</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="annotation">@implementation</span> NSObject (Rayrolling_DVTBezelAlertPanel)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line">+ (<span class="typename">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static</span> dispatch_once_t onceToken;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 6</span></span><br><span class="line">  dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 7</span></span><br><span class="line">    [NSClassFromString(@<span class="string">"DVTBezelAlertPanel"</span>) <span class="string">swizzleWithOriginalSelector:</span><span class="annotation">@selector</span>(<span class="string">initWithIcon:</span><span class="string">message:</span><span class="string">parentWindow:</span><span class="string">duration:</span>) <span class="string">swizzledSelector:</span><span class="annotation">@selector</span>(<span class="string">Rayrolling_initWithIcon:</span><span class="string">message:</span><span class="string">parentWindow:</span><span class="string">duration:</span>) <span class="string">isClassMethod:</span>NO];</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line">- (id)<span class="string">Rayrolling_initWithIcon:</span>(id)icon <span class="string">message:</span>(id)message <span class="string">parentWindow:</span>(id)window <span class="string">duration:</span>(<span class="typename">double</span>)duration</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 9</span></span><br><span class="line">  NSLog(@<span class="string">"Swizzle success! %@"</span>, self);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 10</span></span><br><span class="line">  <span class="keyword">return</span> [self <span class="string">Rayrolling_initWithIcon:</span>icon <span class="string">message:</span>message <span class="string">parentWindow:</span>window <span class="string">duration:</span>duration];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="annotation">@end</span></span><br></pre></td></tr></table></figure>
<p>代码相对的简单明了，解释如下：</p>
<ol>
<li>确保导入要swizzling的方法。</li>
<li>你可以在此声明所有要用到的函数。尽管这不是必要的，但这可以让编译器更好的自动编译你的代码。另外，这个技巧可抑制未声明函数的警告。</li>
<li>这就是你将要swizzling的私有方法。</li>
<li>因为你不想重新声明一个私有类，你可以用分类(category)代替。</li>
<li>这是代码注入“伎俩”的核心。你将在<strong>load</strong>执行注入。<strong>load</strong>函数是唯一的，它里面有<del>一对多的关系</del>。也就是说，同一个类的多个分组都可在一个<strong>load</strong>命令里实现，并执行他们。</li>
<li>由于<strong>load</strong>会被调用多次，所以需要使用<strong>dispatch_once</strong>。</li>
<li>此处使用的是你之前实现过的<strong>NSObject</strong>分类方法。注意，你使用的是<strong>NSClassFromString</strong>来动态检索运行时的私有类。</li>
<li>此处是替代原来的函数。使用一个只有你自己可以规定的唯一命名空间约定，这是一个很好的做法。</li>
<li>此处是测试swizzling能否成功，将字符打印到控制台。</li>
<li>由于你正在swizzle原来的函数，所以当你调用被swizzle的函数时，仍然会调用原来的。这就意味着你可以在原来的方法被调用前后添加一些代码，甚至更改传入的参数…这个一会儿将要用到。</li>
</ol>
<p>恭喜你！你已经成功的将代码注入到一个私有类的私有方法！编译父Xcode，然后编译子Xcode，看看添加控制台的信息是否被swizzle进去了。</p>
<p>现在可以使用Rayrolling的照片替换掉所有编译提示图片了。从<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2015/04/IDEAlertBezel_Generic_Rayrolling.pdf" target="_blank" rel="external">这里</a>下载要swizzle的<a href="http://www.raywenderlich.com/about#cbelanger" target="_blank" rel="external">Crispy</a>的玉照，并将它写入Xcode工程。确保选择上<strong>Copy Items if Needed</strong>。</p>
<p>回到<strong>Rayrolliing_initWithIcon:message:parentWindow:duration</strong>并将其内容更改如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (id)<span class="string">Rayrolling_initWithIcon:</span>(id)arg1 <span class="string">message:</span>(id)arg2 <span class="string">parentWindow:</span>(id)arg3 <span class="string">duration:</span>(<span class="typename">double</span>)arg4 </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (arg1) &#123;  </span><br><span class="line">    NSBundle *bundle = [NSBundle <span class="string">bundleWithIdentifier:</span>@<span class="string">"com.raywenderlich.Rayrolling"</span>];</span><br><span class="line">    NSImage *newImage = [bundle <span class="string">imageForResource:</span>@<span class="string">"IDEAlertBezel_Generic_Rayrolling.pdf"</span>];</span><br><span class="line">    <span class="keyword">return</span> [self <span class="string">Rayrolling_initWithIcon:</span>newImage <span class="string">message:</span>arg2 <span class="string">parentWindow:</span>arg3 <span class="string">duration:</span>arg4];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [self <span class="string">Rayrolling_initWithIcon:</span>arg1 <span class="string">message:</span>arg2 <span class="string">parentWindow:</span>arg3 <span class="string">duration:</span>arg4];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数检查图片是否被传入原来的函数，并将其替换为Rayrolling的图片。需要注意的是你必须要用<strong>+[NSBundle bundleWithIdentifier:]载入图片，因为它并没存储在你的</strong>mainBundle**。<br>编译并运行工程，退出所有的Xcode实体，重启。<br>完美！:]</p>
<h1 id="切换和持久化“雷摇摆”（Rayroll）">切换和持久化“雷摇摆”（Rayroll）</h1><p>你正设计的这个插件也许会惹人烦，很可能你更想让其可以在打开或者关闭状态之间切换，而可以使用<strong>NSUserDefaults</strong>来持久化Xcode的各种实体状态。</p>
<p>回到**Rayrolling.h””，并将如下属性添加到这个头文件：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="list">(<span class="keyword">BOOL</span>)</span>isEnabled<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>到<strong>Rayrolling.m</strong>，并添加如下函数：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)isEnabled &#123;</span><br><span class="line">  <span class="keyword">return</span> [[NSUserDefaults standardUserDefaults] <span class="string">boolForKey:</span>@<span class="string">"com.raywenderlich.Rayrolling.shouldbeEnable"</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">+ (<span class="typename">void</span>)<span class="string">setIsEnabled:</span>(BOOL)shouldBeEnabled &#123;</span><br><span class="line">  [[NSUserDefaults standardUserDefaults] <span class="string">setBool:</span>shouldBeEnabled <span class="string">forKey:</span>@<span class="string">"com.raywenderlich.Rayrolling.shouldbeEnable"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你已经有了持久化你的选择的相关逻辑，现在需要在界面上添加个切换开关。<br>回到<strong>Rayrolling.m</strong>，编辑<em>-(void) doMenuAction*</em>，代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="typename">void</span>)<span class="string">doMenuAction:</span>(NSMenuItem *)menuItem &#123;</span><br><span class="line">  [Rayrolling <span class="string">setIsEnabled:</span>![Rayrolling isEnabled]];</span><br><span class="line">  menuItem.title = [Rayrolling isEnabled] ? @"Disable Rayrolling" : @<span class="string">"Enable Rayrolling"</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This will simply toggle the boolean to either enable or disable Rayrolling.<br>Finally, change the menu setup code in didApplicationFinishLaunchingNotification: to look like the following:<br>这简单实现了切换激活和禁止”Rayrolling”的功能。<br>最后，在<strong>didApplicationFinishLaunchingNotification:</strong>里菜单设置代码，如下：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="name">NSMenuItem</span> *<span class="atom">menuItem</span> = [[<span class="name">NSApp</span> <span class="atom">mainMenu</span>] <span class="atom">itemWithTitle</span>:@<span class="string">"Edit"</span>];</span><br><span class="line"><span class="atom">if</span> (<span class="atom">menuItem</span>) &#123;</span><br><span class="line">  [[<span class="atom">menuItem</span> <span class="atom">submenu</span>] <span class="atom">addItem</span>:[<span class="name">NSMenuItem</span> <span class="atom">separatorItem</span>]];</span><br><span class="line">  <span class="name">NSString</span> *<span class="atom">title</span> = [<span class="name">Rayrolling</span> <span class="atom">isEnabled</span>] ? @<span class="string">"Disable Rayrolling"</span> : @<span class="string">"Enable Rayrolling"</span>;</span><br><span class="line">  <span class="name">NSMenuItem</span> *<span class="atom">actionMenuItem</span> = [[<span class="name">NSMenuItem</span> <span class="atom">alloc</span>] <span class="atom">initWithTitle</span>:<span class="atom">title</span> <span class="atom">action</span>:@<span class="atom">selector</span>(<span class="atom">doMenuAction</span>:) <span class="atom">keyEquivalent</span>:@<span class="string">""</span>];</span><br><span class="line">  [<span class="atom">actionMenuItem</span> <span class="atom">setTarget</span>:<span class="atom">self</span>];</span><br><span class="line">  [[<span class="atom">menuItem</span> <span class="atom">submenu</span>] <span class="atom">addItem</span>:<span class="atom">actionMenuItem</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在你有个菜单项，它会持久化Xcode启动状态，并记住打开或关闭此逻辑的设定。<br>回到<strong>NSObject+Rayrolling_DVTBezelAlertPanel.m</strong>，并添加如下引用：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#import</span> <span class="string">"Rayrolling.h"</span></span><br></pre></td></tr></table></figure></p>
<p>最后，打开<strong>Rayrolling_initWithIcon:message:parentWindow:duration:</strong>，并将<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(arg1)</span> &#123;</span><br></pre></td></tr></table></figure></p>
<p>替换为<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">([Rayrolling isEnabled] &amp;&amp; arg1)</span> &#123;</span><br></pre></td></tr></table></figure></p>
<p>Build and run the program so the changes propagate to the plugin.<br>Boom! You now have a plugin which modifies the Xcode alert and can be toggled on and off. Pretty nice for a day’s work, eh?<br>编译并运行程序，这个变化会有一定的宣传作用。<br>Boom!你现在已经拥有可以编辑Xcode提示，并可以打开和关掉的插件。今天的工作完美收工，是不是？</p>
<h1 id="接下来，做什么？">接下来，做什么？</h1><p>你可以从这里下载本教程的<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2015/05/Rayrolling_Part1_Final.zip" target="_blank" rel="external">完整Rayrolling工程</a>。</p>
<p>虽然你已经有了不少的进展，但是仍然有很多东西要做？在第2部分，你将学习动态跟踪（Dtrace）和探索一些LLDB的高阶特性的基础，可以深入的观察到Xcode正运行的进程。</p>
<p>如果你想预习一些知识，在第3部分前有一些作业，里面有不少汇编代码。现在可通过阅读Mike Ash的关于反汇编的<a href="https://www.mikeash.com/pyblog/friday-qa-2011-12-16-disassembling-the-assembly-part-1.html" target="_blank" rel="external">第1部分</a>和<a href="https://www.mikeash.com/pyblog/friday-qa-2011-12-23-disassembling-the-assembly-part-2.html" target="_blank" rel="external">第2部分</a>文章，来学习和补充一些X86_64的汇编知识。这两篇文章对理解接下来的内容很有帮助。</p>
<p>好运吧，祝愉快！如果你关于本教程有任何的意见和问题，请在<a href="http://www.raywenderlich.com/94020/creating-an-xcode-plugin-part-1" target="_blank" rel="external">下面</a>留言。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/02/12/如何制作Xcode插件：1-3/" data-id="cikkpj8gq0001kn053rdkangp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/04/hello-world/" class="article-date">
  <time datetime="2015-06-04T14:56:15.000Z" itemprop="datePublished">2015-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/04/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/04/hello-world/" data-id="cikkpj8fy0000kn05915kgmmm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/02/13/[如何制作Xcode插件：1-3](http:--http:--www.raywenderlich.com-94020-creating-an-xcode-plugin-part-1)/">(no title)</a>
          </li>
        
          <li>
            <a href="/2016/02/13/如何制作Xcode插件：1-3-1/">(no title)</a>
          </li>
        
          <li>
            <a href="/2016/02/12/如何制作Xcode插件：1-3/">(no title)</a>
          </li>
        
          <li>
            <a href="/2015/06/04/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>